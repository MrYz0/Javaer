---
title: SpringMVC
date: 2022-07-21 09:19:04
permalink: /pages/123407/
categories:
  - 框架
  - Spring
tags:
  - 
author: 
  name: 杨洲
  link: https://github.com/xugaoyi
---


# SpringMVC

## 一、SpringMVC简介

​	SpringMVC是隶属于Spring框架的一部分，主要是用来进行Web开发，是对Servlet进行了封装。

​	SpringMVC是处于Web层的框架，所以其主要的作用就是用来接收前端发过来的请求和数据然后经过

​	处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容。

​	REST是一种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，后期的应用也是非常广

泛。

**1**，SpringMVC概述

学习SpringMVC我们先来回顾下现在web程序是如何做的，咱们现在web程序大都基于三层架构来实

现。

三层架构

![1652190532602](/JavaCore/img/SpringMVC/SpringMVC-1.png)

- 浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据

- 如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利

- 将后端服务器Servlet拆分成三层，分别是web、service和dao
  - web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端
  - service层主要负责业务逻辑的处理
  - dao层主要负责数据的增删改查操作

- servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求

- 针对web层进行了优化，采用了MVC设计模式，将其设计为controller、view和Model

  - controller负责请求和数据的接收，接收后将其转发给service进行业务处理

  - service根据需要会调用dao对数据进行增删改查
  - dao把数据处理完后将结果交给service,service再交给controller
  - controller根据需求组装成Model和View,Model和View组合起来生成页面转发给前端浏览
  - 器

  - 这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操
  - 作。

随着互联网的发展，上面的模式因为是同步调用，性能慢慢的跟不是需求，所以异步调用慢慢的走到

了前台，是现在比较流行的一种处理方式

![1652190555268](/JavaCore/img/SpringMVC/SpringMVC-2.png)

- 因为是异步调用，所以后端不需要返回view视图，将其去除
- 前端如果通过异步调用的方式进行交互，后台就需要将返回的数据转换成json格式进行返回
- SpringMVC**主要**负责的就是
  - controller如何接收请求和数据
  - 如何将请求和数据转发给业务层
  - 如何将响应数据转换成json发回到前端

介绍了这么多，对SpringMVC进行一个定义

- SpringMVC是一种基于Java实现MVC模型的轻量级Web框架
- 优点
  - 使用简单、开发便捷(相比于Servlet)
  - 灵活性强

## 二、SpringMVC入门案例

①：导入SpringMVC坐标与Servlet坐标

```xml
<dependencies>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope> 
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>
  </dependencies>

 <build>
    <plugins>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.1</version>
        <configuration>
          <port>80</port>
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
```

②：初始化SpringMVC配置环境（同Spring环境）

```java
@Configuration
public class SpringMVCConfig {
}
```

③：创建SpringMVC控制器类（等同于`Servlet`功能）

```java
@Controller
public class UserController {
    @RequestMapping("/save")
    public String save(){
        System.out.println("user save.....");
        return "{'info':'yangzhou'}";
    }
}
```

④：设定SpringMVC加载对应的bean

```java
@Configuration
@ComponentScan("com.yz.mvc.controller")
public class SpringMVCConfig {
}
```

⑤：初始化Servlet容器，加载SpringMVC环境，并设这SpringMVC请求拦截路径

```java
public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {
    //加载springmvc对应的容器对象
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(SpringMVCConfig.class);
        return context;
    }

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
```

⑥：使用浏览器测试请求

![1652174120277](/JavaCore/img/SpringMVC/SpringMVC-3.png)

:::  tip 注意

由于未设定请求执行后响应的页面信息，页面显示空白，后台输出代码正常运行

:::

⑦：设定请求的返回值为字符串类型，并返回自定义json数据

```java
@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("user save.....");
        return "{'info':'yangzhou'}";
    }
}
```

::: info 总结

- 名称:@Controller
- 类型:`类注解`
- 位置：SpringMVC控制器类定义上方
- 作用：设定SpringMVC核心控制器bean
- 范例

```java
public class UserController {
}
```

- 相关属性

  - value（默认）：请求访问路径

- 名称：ResponseBody

- 类型：`方法注解`

- 位置：SpringMVC控制器类定义上方

- 作用：设置当前控制器方法响应内容为当前返回值，无需解析

- 范例：

  ```java
  @RequestMapping("/save")
  @ResponseBody
  public String save(){
       System.out.println("user save.....");
       return "{'info':'yangzhou'}";
  } 
  ```

- AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化web3.0容器的抽象类

- AbstractDispatcherServletInitializer提供了三个接口方法供用户使用

  - createServletApplicationContext( )方法，创建Servlet容器时，加载SpringMVC对应的bean并放入
  - WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围

  ```java
   protected WebApplicationContext createServletApplicationContext() {
          AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
          context.register(SpringMVCConfig.class);
          return context;
      }
  ```

  - getServletMappings( )方法，设定SpringMVC对应的请求映射路径，设置为/表示拦截所有请求，任意请求都将转入到SpringMVC中进行处理

  ```java
  protected String[] getServletMappings() {
          return new String[]{"/"};
      }
  ```

  - createRootApplicationContext（）方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，使用同createServletApplicationContext（）

  ```java
  protected WebApplicationContext createRootApplicationContext() {
          return null;
      }
  ```

- SpringMVV入门程序总结

  - 一次性工作
    - 创建工程，设置服务器，加载工程
    - 导入坐标
    - 创建web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径
    - SpringMVC核心配置类（设置配置类，扫描controller包，加载Controller控制器bean）
  - 多次工作
    - 定义处理请求的控制器类
    - 定义处理请求的控制器方法，并配置映射路径(@RequestMapping)与返回json数据(@ResponseBody)

:::

## 三、入门案例工作流程分析

**启动服务器初始化过程**

1. 服务器启动，执行ServletContainersInitConfig类，初始化web容器
2. 执行createServletApplicationContext方法，创建了WebApplicationContext对象
3. 加载SpringMvcConfig
4. 执行@Componentscan加载对应的bean
5. 加载UserController,每个@RequestMapping的名称对应一个其体的方法
6. 执行getservletMappings方法，定义所有的请求都通i过SpringMVC



::: tip

- 名称：@ComponentScan
- 类型：`类注解`
- 范例

```java
@Configuration
//@ComponentScan({"com.yz.service","com.yz.mapper"})
@ComponentScan(value = "com.yz",
               excludeFilters = @ComponentScan.Filter(
                       type = FilterType.ANNOTATION
               ))
public class SpringConfig {
}
```

- 属性
  - excludeFilters:排除扫描路径中加载的bean，需要指定类别（type）与具体项（classes）
  - includeFilters：加载指定的bean，需要制定类别（type）与具体项（classes）

:::

- bean加载格式

```java
public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context=new AnnotationConfigWebApplicationContext();
        context.register(SpringMVCConfig.class);
        return context;
    }
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        AnnotationConfigWebApplicationContext context=new AnnotationConfigWebApplicationContext();
        context.register(SpringConfig.class);
        return context;
    }
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

}
```

- 简化开发

```java
public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMVCConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}    
```

## 四、请求与响应

### 4.1 请求映射路径

- 名称：@RequestMapping
- 类型：`方法注解类注解`
- 位置：SpringMVC控制器类定义上方
- 作用：设置当前控制器方法请求访问路径，如果设置在类上统一当前控制器方法请求访问路径前缀
- 范例

```java
@RequestMapping("/user")
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("save....");
        return "{'info':'yangzhou'}";
    }
}
```

- 属性
  - value（默认）：请求访问路径，或访问路径前缀

### 4.2  **请求参数**

#### 4.2.1 Get请求

- 普通请求路径：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数

![1652187852161](/JavaCore/img/SpringMVC/SpringMVC-4.png)

```java
@Controller
public class UserController {
    //普通参数
    @RequestMapping("/commonParam")
    @ResponseBody
    public String save(String username,String password){
        System.out.println("普通参数传递 name=》"+username);
        System.out.println("普通参数传递 password=》"+password);
        return "{'modul':'common param'}";
    }
}
```

Get请求中文乱码处理

#### 4.2.2 Post请求

- 普通参数：form表单post请求传参，表单参数名与形参变量名相同，定义形参即可接收参数

![1652187949354](/JavaCore/img/SpringMVC/SpringMVC-5.png)

```java
@Controller
public class UserController {
    //普通参数
    @RequestMapping("/commonParam")
    @ResponseBody
    public String save(String username,String password){
        System.out.println("普通参数传递 name=》"+username);
        System.out.println("普通参数传递 password=》"+password);
        return "{'modul':'common param'}";
    }
}
```

Post请求中文乱码处理

- 为web容器添加过滤器并指定字符集，Spring-Web包中提供了专用的字符过滤器

```java
    //乱码处理
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter encodingFilter=new CharacterEncodingFilter();
        encodingFilter.setEncoding("UTF-8");
        return new Filter[]{encodingFilter};
    }
```

### 4.3 五种类型请求参数

#### 4.3.1 普通参数

#### 4.3.2 Pojo参数数据类型

> 请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数

![1652191062980](/JavaCore/img/SpringMVC/SpringMVC-6.png)

```java
//Pojo参数
    @RequestMapping("/pojoParam")
    @ResponseBody
    public String pojoParam(User user){
        System.out.println("pojo user=>"+user);
        return "{'modul':'common param'}";
    }
```

#### 4.3.3 嵌套Pojo参数类型

> POJO对象中包含POJO对象，请求参数与形参对象属性相同，按照对象层次结构即可接收嵌套POJO属性参数

![1652191201335](/JavaCore/img/SpringMVC/SpringMVC-7.png)

![1652191229813](/JavaCore/img/SpringMVC/SpringMVC-8.png)

![1652191323005](/JavaCore/img/SpringMVC/SpringMVC-9.png)

```java
//嵌套Pojo参数
    @RequestMapping("/pojoContainParam")
    @ResponseBody
    public String pojoContainParam(User user){
        System.out.println("pojo user=>"+user);
        return "{'modul':'common param'}";
    }
```

#### 4.3.4 数组参数类型

> 请求参数与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数

![1652191397875](/JavaCore/img/SpringMVC/SpringMVC-10.png)

```java
 //数组参数
    @RequestMapping("/arryParam")
    @ResponseBody
    public String arryParam(String[] likes){
        System.out.println("pojo user=>"+ Arrays.toString(likes));
        return "{'modul':'common param'}";
    }
```

#### 4.3.5 集合参数类型

> 请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系

![1652191418382](/JavaCore/img/SpringMVC/SpringMVC-11.png)

```java
//集合参数
    @RequestMapping("/listParam")
    @ResponseBody
    public String listParam(@RequestParam List<String> likes){
        System.out.println("pojo user=>"+ likes);
        return "{'modul':'common param'}";
    }
```

### 4.3 日期类型参数传递

- 日期类型基于系统不同格式也不尽相同
  - 2088-08-18
  - 2088/08/18
  - 08/18/2088

![1652193754646](/JavaCore/img/SpringMVC/SpringMVC-12.png)

```java
@RequestMapping("/dataParam") 

@ResponseBody 

public String dataParam(Date date){ 

	System.out.println("参数传递 date ==> "+date); 

	return "{'module':'data param'}"; 

} 
```

**不同时间类型类型**

![1652194340319](/JavaCore/img/SpringMVC/SpringMVC-13.png)

```java
 //日期参数
    @RequestMapping("/dataParam")
    @ResponseBody
    public String dataParam(Date date,
                            @DateTimeFormat(pattern = "yyyy-MM-dd") Date date1,
                            @DateTimeFormat(pattern = "yyyy/MM/dd HH:mm:ss") Date date2) {
        System.out.println("参数传递 date ==> " + date);
        System.out.println("参数传递 date1(yyyy-MM-dd) ==> " + date1);
        System.out.println("参数传递 date2(yyyy/MM/dd HH:mm:ss) ==> " + date2);
        return "{'module':'data param'}";
    }
```

此处汇报错:解决方法—**SpringMVC**的配置类把@EnableWebMvc当做标配配置上去

::: tip 知识点

@DateTimeFormat

**名称** ：**@DateTimeFormat**

类型 ：**形参注解**

位置 ：SpringMVC控制器方法形参前面

作用 ：设定日期时间型数据格式

相关属性 ：pattern：指定日期时间格式字符串

:::

类型转换器

- Converter接口

```java
public interface Converter<S, T> {
	@Nullable
	T convert(S source);
}
```

- 请求参数年龄数据（String→Integer）
- 日期格式转换（String → Date）



### 4.4 响应json数据

- json数组
- json对象（POJO）
- json数组（POJO）

①：添加json数据转换相关左边

```xml
 <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.13.2.1</version>
    </dependency>
```

②：设置发送json数据（请求body中添加数据）

![1652195489210](/JavaCore/img/SpringMVC/SpringMVC-14.png)

③：开启自动转换json数据的支持

在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。

```java
@Configuration
@EnableWebMvc
@ComponentScan("com.yz.controller")
public class SpringMVCConfig {
}
```

④：设置接收json数据

```java
 //集合参数：json格式
    @RequestMapping("/listParam")
    @ResponseBody
    public String listParam(@RequestBody List<String> likes) {
        System.out.println("pojo user=>" + likes);
        return "{'modul':'common param'}";
    }
```

::: tip 知识点1

**名称** :**@EnableWebMvc**

类型 :**配置类注解**

位置 :SpringMVC配置类定义上方

作用 :开启SpringMVC多项辅助功能

:::

::: tip 知识点2

**名称** :**@RequestBody**

类型 :**形参注解**

位置 :SpringMVC控制器方法形参定义前面

作用 :将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次

:::

@`RequestBody与@RequestParam的区别`

- 区别

  - @RequestParam用于接收url地址传参，表单传参【`application/x-www-formurlencoded`】

  - @RequestBody用于接收json数据【application/json】

- 应用

  - 后期开发中，发送json格式数据为主，@RequestBody应用较广
  - 如果发送非json格式数据，选用@RequestParam接收请求参数

**更多 @RequestBody和@RequestParam区别知识点补充前往文章处了解**

### 4.5 响应

- 响应页面

```java
//响应页面/跳转页面
    @RequestMapping("toJumpPage")
    public String toJumpPage(){
        System.out.println("跳转页面");
        return "index.jsp";
    }
```



- 响应数据

  - 文本数据

  ```java
   //响应文本数据
      @RequestMapping("ToText")
      @ResponseBody
      public String ToText(){
          System.out.println("返回纯文本数据");
          return "response text";
      }
  ```

  - json数据

  ```java
  //响应POJO对象
      @RequestMapping("toJsonPOJO")
      @ResponseBody
      public User toJsonPOJO(){
          System.out.println("返回json对象数据");
          User user=new User();
          user.setUsername("杨洲");
          user.setPassword("123456");
          return user;
      }
  ```

  - json数据（对象集合转json数组）

  ```java
  //响应POJO集合对象
      @RequestMapping("toJsonList")
      @ResponseBody
      public List<User> toJsonList(){
          System.out.println("返回json集合数据");
          User user1=new User();
          user1.setUsername("熊大");
          user1.setPassword("123456");
  
          User user2=new User();
          user2.setUsername("熊二");
          user2.setPassword("123456");
  
          List<User> userList = new ArrayList<>();
          userList.add(user1);
          userList.add(user2);
  
          return userList;
      }
  ```

::: tip 知识点

- 名称：@ResponseBody
- 类型：`方法注解`
- 位置：SpringMVC控制器方法定义上方
- 作用：设置当前控制器方法响应内容为当前返回，无需解析
- 范例：

```java
 @RequestMapping("ToText")
    @ResponseBody
    public String ToText(){
        System.out.println("返回纯文本数据");
        return "response text";
    }
```

:::

## 五、REST风格

### 5.1 REST简介

- ==REST==（Representational State Transfer），表现形式状态转换,它是一种软件架构==风格==

  当我们想表示一个网络资源的时候，可以使用两种方式:

  * 传统风格资源描述形式
    * `http://localhost/user/getById?id=1` 查询id为1的用户信息
    * `http://localhost/user/saveUser` 保存用户信息
  * REST风格描述形式
    * `http://localhost/user/1`
    * `http://localhost/user`

传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全，因为会程序的人读取了你的请求url地址，就大概知道该url实现的是一个什么样的操作。

查看REST风格的描述，你会发现请求地址变的简单了，并且光看请求URL并不是很能猜出来该URL的具体功能

所以REST的优点有:

- 隐藏资源的访问行为，无法通过地址得知对资源是何种操作
- 书写简化

但是我们的问题也随之而来了，一个相同的url地址即可以是新增也可以是修改或者查询，那么到底我们该如何区分该请求到底是什么操作呢?

* 按照REST风格访问资源时使用==行为动作==区分对资源进行了何种操作
  * `http://localhost/users`	查询全部用户信息   GET（查询）
  * `http://localhost/users/1`  查询指定用户信息 GET（查询）
  * `http://localhost/users`    添加用户信息           POST（新增/保存）
  * `http://localhost/users`    修改用户信息           PUT（修改/更新）
  * `http://localhost/users/1`  删除用户信息        DELETE（删除）

请求的方式比较多，但是比较常用的就4种，分别是`GET`,`POST`,`PUT`,`DELETE`。

按照不同的请求方式代表不同的操作类型。

* 发送GET请求是用来做查询
* 发送POST请求是用来做新增
* 发送PUT请求是用来做修改
* 发送DELETE请求是用来做删除

但是==注意==:

* 上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范
  * REST提供了对应的架构方式，按照这种架构设计项目可以降低开发的复杂性，提高系统的可伸缩性
  * REST中规定GET/POST/PUT/DELETE针对的是查询/新增/修改/删除，但是我们如果非要用GET请求做删除，这点在程序上运行是可以实现的
  * 但是如果绝大多数人都遵循这种风格，你写的代码让别人读起来就有点莫名其妙了。
* 描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如:users、books、accounts......

清楚了什么是REST风格后，我们后期会经常提到一个概念叫`RESTful`，那什么又是RESTful呢?

* 根据REST风格对资源进行访问称为==RESTful==。

后期我们在进行开发的过程中，大多是都是遵从REST风格来访问我们的后台服务，所以可以说咱们以后都是基于RESTful来进行开发的。

### 5.2 RESTful入门案例

#### 5.2.1 环境准备

- 创建一个Web的Maven项目
- pom.xml添加Spring依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.itheima</groupId>
  <artifactId>springmvc_06_rest</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <dependencies>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.0</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.1</version>
        <configuration>
          <port>80</port>
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

- 创建对应的配置类

```java
public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    //乱码处理
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter = new CharacterEncodingFilter();
        filter.setEncoding("UTF-8");
        return new Filter[]{filter};
    }
}

@Configuration
@ComponentScan("com.itheima.controller")
//开启json数据类型自动转换
@EnableWebMvc
public class SpringMvcConfig {
}
```

- 编写模型类User

```java
@Data
public class User {
    private String name;
    private int age;
}
```

- 编写UserController

```java
@Controller
public class UserController {
	@RequestMapping("/save")
    @ResponseBody
    public String save(@RequestBody User user) {
        System.out.println("user save..."+user);
        return "{'module':'user save'}";
    }

    @RequestMapping("/delete")
    @ResponseBody
    public String delete(Integer id) {
        System.out.println("user delete..." + id);
        return "{'module':'user delete'}";
    }

    @RequestMapping("/update")
    @ResponseBody
    public String update(@RequestBody User user) {
        System.out.println("user update..." + user);
        return "{'module':'user update'}";
    }

    @RequestMapping("/getById")
    @ResponseBody
    public String getById(Integer id) {
        System.out.println("user getById..." + id);
        return "{'module':'user getById'}";
    }

    @RequestMapping("/findAll")
    @ResponseBody
    public String getAll() {
        System.out.println("user getAll...");
        return "{'module':'user getAll'}";
    }
}
```

最终创建好的项目结构如下:

![1652282042767](/JavaCore/img/SpringMVC/SpringMVC-15.png)

#### 5.2.2 思路分析

> 需求:将之前的增删改查替换成RESTful的开发方式。
>
> 1.之前不同的请求有不同的路径,现在要将其修改为统一的请求路径
>
> 修改前: 新增: /save ,修改: /update,删除 /delete...
>
> 修改后: 增删改查: /users
>
> 2.根据GET查询、POST新增、PUT修改、DELETE删除对方法的请求方式进行限定
>
> 3.发送请求的过程中如何设置请求参数?

#### 5.2.3 修改RESTful风格

**新增**

```java
@RequestMapping(value = "/users",method = RequestMethod.POST) //==@PostMapping()
    @ResponseBody
    public String save(User user){
        System.out.println("user save...."+user);
        return "{'module':'user save'}";
    }
```

**删除**

```java
@RequestMapping(value = "/users/{id}",method = RequestMethod.DELETE)
    @ResponseBody
    public String delete(@PathVariable Integer id){
        System.out.println("user delete...."+id);
        return "{'module':'user delete'}";
    }
```

**修改**

```java
   @RequestMapping(value = "/update",method = RequestMethod.PUT)
    @ResponseBody
    public String update(@RequestBody User user){
        System.out.println("user update...."+user);
        return "{'module':'user update'}";
    }
```

**查询单个**

```java
   @RequestMapping(value = "/users/{id}",method = RequestMethod.GET)
    @ResponseBody
    public String getById(@PathVariable Integer id){
        System.out.println("user getById...."+id);
        return "{'module':'user getById'}";
    }
```

**查询所有**

```java
 @RequestMapping(value = "/users",method = RequestMethod.GET)
    @ResponseBody
    public String getAll(){
        System.out.println("user getAll....");
        return "{'module':'user getAll'}";
    }
```

::: info **小结**

RESTful入门案例，我们需要学习的内容如下:

(1)设定Http请求动作(动词)

@RequestMapping(value="",==method== = RequestMethod.==POST|GET|PUT|DELETE==)

(2)设定请求参数(路径变量)

@RequestMapping(value="/users/=={id}==",method = RequestMethod.DELETE)

@ReponseBody

public String delete(==@PathVariable== Integer ==id==){

}

:::

#### 知识点1：@PathVariable

| 名称 | @PathVariable                                                |
| ---- | ------------------------------------------------------------ |
| 类型 | ==形参注解==                                                 |
| 位置 | SpringMVC控制器方法形参定义前面                              |
| 作用 | 绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应 |

关于接收参数，我们学过三个注解`@RequestBody`、`@RequestParam`、`@PathVariable`,这三个注解之间的区别和应用分别是什么?

* 区别
  * @RequestParam用于接收url地址传参或表单传参
  * @RequestBody用于接收json数据
  * @PathVariable用于接收路径参数，使用{参数名称}描述路径参数
* 应用
  * 后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广
  * 如果发送非json格式数据，选用@RequestParam接收请求参数
  * 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值

### 5.3 REST快速开发

```java
@RestController //@Controller + ReponseBody
@RequestMapping("/books")
public class BookController {
    
	//@RequestMapping(method = RequestMethod.POST)
    @PostMapping
    public String save(@RequestBody Book book){
        System.out.println("book save..." + book);
        return "{'module':'book save'}";
    }

    //@RequestMapping(value = "/{id}",method = RequestMethod.DELETE)
    @DeleteMapping("/{id}")
    public String delete(@PathVariable Integer id){
        System.out.println("book delete..." + id);
        return "{'module':'book delete'}";
    }

    //@RequestMapping(method = RequestMethod.PUT)
    @PutMapping
    public String update(@RequestBody Book book){
        System.out.println("book update..." + book);
        return "{'module':'book update'}";
    }

    //@RequestMapping(value = "/{id}",method = RequestMethod.GET)
    @GetMapping("/{id}")
    public String getById(@PathVariable Integer id){
        System.out.println("book getById..." + id);
        return "{'module':'book getById'}";
    }

    //@RequestMapping(method = RequestMethod.GET)
    @GetMapping
    public String getAll(){
        System.out.println("book getAll...");
        return "{'module':'book getAll'}";
    }
    
}
```

对于刚才的问题，我们都有对应的解决方案：

问题1：每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高。

```
将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。
```

问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。

```
使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替
```

问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。

```
1.将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能
2.使用@RestController注解替换@Controller与@ResponseBody注解，简化书写
```

::: info 知识点

#### 知识点1：@RestController

| 名称 | @RestController                                              |
| ---- | ------------------------------------------------------------ |
| 类型 | ==类注解==                                                   |
| 位置 | 基于SpringMVC的RESTful开发控制器类定义上方                   |
| 作用 | 设置当前控制器类为RESTful风格，<br/>等同于@Controller与@ResponseBody两个注解组合功能 |

#### 知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping

| 名称     | @GetMapping @PostMapping @PutMapping @DeleteMapping          |
| -------- | ------------------------------------------------------------ |
| 类型     | ==方法注解==                                                 |
| 位置     | 基于SpringMVC的RESTful开发控制器方法定义上方                 |
| 作用     | 设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，<br/>例如@GetMapping对应GET请求 |
| 相关属性 | value（默认）：请求访问路径                                  |

:::

### 5.4 案例：基于 RESTful页面数据交互

#### ①：制作SpringMVC控制器，并通过PostMan测试接口说明

```java
@RestController
@RequestMapping("/books")
public class BookController {
    @PostMapping
    public String save(@RequestBody Book book){
        System.out.println("Book save 。。。。"+book);
        return "{'module':'book save success'}";
    }
    @GetMapping
    public List<Book> getAll(){
        List<Book> bookList=new ArrayList<>();
        Book book1=new Book();
        book1.setType("计算机");
        book1.setName("SpringMVC入门案例");
        book1.setDescription("小试牛刀");
        bookList.add(book1);
        System.out.println("获得图书列表成功。。。。。。");
        return bookList;
    }
}
```

#### ②：设置对静态资源的访问放行

```java
@Configuration
public class SpringMvcSupprot extends WebMvcConfigurationSupport {

    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        //当访问/pages/？？？时，走/pages目录下的内容
        registry.addResourceHandler("/pages/**").addResourceLocations("/pages/");
        registry.addResourceHandler("/js/**").addResourceLocations("/js/");
        registry.addResourceHandler("/css/**").addResourceLocations("/css/");
        registry.addResourceHandler("/plugins/**").addResourceLocations("/plugins/");
    }
}

@Configuration
@ComponentScan({"com.yz.controller","com.yz.config"})
@EnableWebMvc
public class SpringMVCConfig {
}
```

#### ③：前端页面通过异步提交访问后台控制器

```java
//添加
                saveBook () {
                    axios.post("/books",this.formData).then((res)=>{

                    });
                },

                //主页列表查询
                getAll() {
                    axios.get("/books").then((res)=>{
                        this.dataList = res.data;
                    });
                },
```

结果：

![1652338182966](/JavaCore/img/SpringMVC/SpringMVC-16.png)

## 六、SSM整合

流程：

> 1.创建工程
>
> 2.SSM整合
>
> - Spring
    >   - SpringConfig
> - MyBatis
    >   - MyBatisConfig
>   - JdbcConfig
>   - jdbc.properties
> - SpringMVC
    >   - ServletConfig
>   - SpringMVCConfig
>
> 3.功能模块
>
> - 表与实体类
> - dao（接口与自动代理）
> - service（接口与实现类）
    >   - 业务层接口测试（整合JUnit）
> - controller
    >   - 表现层接口测试（PostMan）

### 6.1Spring整合MyBatis

#### 6.1.1 配置

- SpringConfig

```java
@Configuration
@ComponentScan("com.yz.service")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class,MyBatisConfig.class})
@EnableTransactionManagement
public class SpringConfig {
}

```

- JdbcConfig、jdbc.properties

```java
public class JdbcConfig {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource dataSource=new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource){
        DataSourceTransactionManager ds =new DataSourceTransactionManager();
        ds.setDataSource(dataSource);
        return ds;
    }
}
```

```xml
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssm_db
jdbc.username=root
jdbc.password=123456
```

- ServletConfig

```java
public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

#### 6.1.2 数据模型

- Book

```java
@Data
public class Book {
    private Integer id;
    private String type;
    private String name;
    private String description;
}
```

#### 6.1.3 数据层标准开发

```java
public interface BookDao {

    /**
     *添加
     * @param book
     * @return void
     */
    @Insert("insert into tbl_book (type,name,description) values(#{type},#{name},#{description})")
    public void save(Book book);

    /**
     * 修改
     * @param book
     * @return void
     */
    @Update("UPDATE tbl_book set type=#{type} , name=#{name},description=#{description} where id = #{id}")
    public void updaet(Book book);
    /**
     * 删除
     * @param id
     * @return void
     */
    @Delete("delete from tbl_book where id=#{id}")
    public void delete(Integer id);
    /**
     * 查询单个
     * @param id
     * @return com.yz.entity.Book
     */
    @Select("select * from tbl_book where id=#{id}")
    public Book getById(Integer id);
    /**
     * 查询全部
     * @param
     * @return java.util.List<com.yz.entity.Book>
     */
    @Select("select * from tbl_book")
    public List<Book> getAll();
}
```

#### 6.1.4 业务层标准开发

- BookSerivice
- BookServiceImpl

```java
@Transactional  //事务处理
public interface BookService {

    public boolean save(Book book);

    public boolean updaet(Book book);

    public boolean delete(Integer id);

    public Book getById(Integer id);

    public List<Book> getAll();
}

```

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    private BookDao bookDao;

    @Override
    public boolean save(Book book) {
        bookDao.save(book);
        return true;
    }

    @Override
    public boolean updaet(Book book) {
        bookDao.updaet(book);
        return true;
    }

    @Override
    public boolean delete(Integer id) {
        bookDao.delete(id);
        return true;
    }

    @Override
    public Book getById(Integer id) {
        return bookDao.getById(id);
    }

    @Override
    public List<Book> getAll() {
        return bookDao.getAll();
    }
}
```

#### 6.1.5 测试接口

- BookController

```java
@RestController
@RequestMapping("/books")
public class BookController {
    @Autowired
    private BookService bookService;

    @PostMapping
    public boolean save(@RequestBody Book book){
        return bookService.save(book);
    }

    @PutMapping
    public boolean update(@RequestBody Book book){
        return bookService.updaet(book);
    }
    @DeleteMapping("{id}")
    public boolean delete(@PathVariable Integer id){
        return bookService.delete(id);
    }

    @GetMapping("{id}")
    public Book getById(@PathVariable Integer id){
        return bookService.getById(id);
    }
    @GetMapping
    public List<Book> getAll(){
        return bookService.getAll();
    }
}
```

### 6.2 **统一结果封装**

#### 6.2.1 **表现层与前端数据传输协议定义**

SSM整合以及功能模块开发完成后，接下来，我们在上述案例的基础上分析下有哪些问题需要我们去解

决下。首先第一个问题是:

- 在Controller层增删改返回给前端的是boolean类型数据

![1652508518750](/JavaCore/img/SpringMVC/SpringMVC-17.png)

- 在Controller层查询单个返回给前端的是对象

![1652508510861](/JavaCore/img/SpringMVC/SpringMVC-18.png)

- 在Controller层查询所有返回的前端是集合对象

  ![1652508615207](/JavaCore/img/SpringMVC/SpringMVC-19.png)

目前我们就有三种数据类型返回给前端，如果随着业务的增长，我们需要返回的数据类型会越来越多。对于前端开发人员在解析数据的时候就会比较凌乱了，所以对于前端来说，如果后台能够返回一个统一的数据结果，前端在解析的时候就可以按照一种方式进行解析。开发就会变得更加简单。

所以我们就想能不能返回结果的数据进行统一 ，具体如何来做，大体的思路为：

- 为了封装返回数据的结果：`创建结果模型类，封装到data属性中`
- 为了封装返回的数据是何种操作以及是否操作成功：`封装操作结果到code属性中`
- 操作失败后为了封装返回的错误信息：`封装特殊消息到message（msg）属性中`

![1652508975558](/JavaCore/img/SpringMVC/SpringMVC-20.png)

根据分析，我们设置统一数据返回结果类

```java
public class Result {
    private Object  data;
    private Integer code;
    private String  msg;
}    
```

::: tip 注意

Result类名及类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作

:::

#### 6.2.2 表现层与前端数据传输协议实现

##### 6.2.2.1 结果封装

**步骤一：创建Result类**

```java
public class Result {
	//统一返回的数据
    private Object  data;
    //统一格式中的编码，用于区分操作，可以简化配置0或1表示成功和失败
    private Integer code;
    //统一格式中的消息，可选属性
    private String  msg;
    public Result() {

    }
    //构造方法是方便对象的创建
    public Result(Integer code,Object data ) {
        this.data = data;
        this.code = code;

    }
    //构造方法是方便对象的创建
    public Result( Integer code,Object data, String msg) {
        this.data = data;
        this.code = code;
        this.msg = msg;
    }
	//setter ....和getter....省略
}    
```

**步骤二：定义返回码Code类**

```java
public class Code {
    public static final Integer SAVE_OK = 201;
    public static final Integer DELETE_OK = 202;
    public static final Integer UPDATE_OK = 203;
    public static final Integer GET_OK = 204;

    public static final Integer SAVE_ERR = 401;
    public static final Integer DELETE_ERR = 402;
    public static final Integer UPDATE_ERR = 403;
    public static final Integer GET_ERR = 404;

}
```

**步骤三：修改Controller类的返回值**

```java
@RestController
@RequestMapping("/books")
public class BookController {
    @Autowired
    private BookService bookService;

    @PostMapping
    public Result save(@RequestBody Book book){
        boolean flag = bookService.save(book);

        return new Result(flag ? Code.SAVE_OK:Code.SAVE_ERR,flag);
    }

    @PutMapping
    public Result update(@RequestBody Book book){
        boolean flag = bookService.updaet(book);

        return new Result(flag ? Code.UPDATE_OK:Code.UPDATE_ERR,flag);
    }
    @DeleteMapping("{id}")
    public Result delete(@PathVariable Integer id){


        boolean flag = bookService.delete(id);

        return new Result(flag ? Code.DELETE_OK:Code.DELETE_ERR,flag);
    }

    @GetMapping("{id}")
    public Result getById(@PathVariable Integer id){
        int i=1/0;
        Book book = bookService.getById(id);
        Integer code = book !=null ? Code.GET_OK :Code.GET_ERR;
        String msg = book != null ? " ": "数据查询失败，请重试";

        return new Result(code,book,msg);
    }
    @GetMapping
    public Result getAll(){
        List<Book> bookList = bookService.getAll();
        Integer code = bookList !=null ? Code.GET_OK :Code.GET_ERR;
        String msg = bookList != null ? " ": "数据查询失败，请重试";

        return new Result(code,bookList,msg);
    }
    
}
```

**步骤四:启动服务测试**

![1652509757715](/JavaCore/img/SpringMVC/SpringMVC-21.png)

至此，我们的返回结果就已经能以一种统一的格式返回给前端。前端根据返回的结果，先从中获取`code`根据code判断，如果成功则获取`msg`属性的值，如果失败，则获取`msg`中的值做出提示。

### 6.3 统一异常处理

#### 6.3.1  问题描述

在讲解这一部分知识点之前，我们先来演示个效果，修改BookController类的getById方法

```java
    @GetMapping("{id}")
    public Result getById(@PathVariable Integer id){
        //手动添加一个错误信息
        if (id==1){
            int i =1/0;
        }
        Book book = bookService.getById(id);
        Integer code = book !=null ? Code.GET_OK :Code.GET_ERR;
        String msg = book != null ? " ": "数据查询失败，请重试";
        return new Result(code,book,msg);
    }
```

测试会出现如下效果：

![1652601805376](/JavaCore/img/SpringMVC/SpringMVC-22.png)

前端接收到这个信息后和之前我们约定的格式不一致，这个问题该如何解决?

在解决问题之前，我们先来看下异常的种类及出现异常的原因:

- 框架内部抛出的异常：因使用不合规导致

- 数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）

- 业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）

- 表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）

- 工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）

看完上面这些出现异常的位置，你会发现，在我们开发的任何一个位置都有可能出现异常，而且这些

异常是不能避免的。所以我们就得将异常进行处理。

**思考**

1. 各个层级均出现异常，异常处理代码书写在哪一层?

**所有的异常均抛出到表现层进行处理**

2. 异常的种类很多，表现层如何将所有的异常都处理到呢?

**异常分类**

3. 表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决?

**AOP**

对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:

- 异常处理器:
  - 集中的、统一的处理项目中出现的异常

```java
@RestControllerAdvice
public class ProjectExceptionAdvice {
    @ExceptionHandler(Exception.class)  //拦截异常
    public Result doException(Exception ex){
        System.out.println("出现异常");
        return new Result(400,null,"出现异常");
    }
}
```

结果：

![1652602024698](/JavaCore/img/SpringMVC/SpringMVC-23.png)

**知识点1：@RestControllerAdvice**

| 名称 | **@RestControllerAdvice**          |
| ---- | ---------------------------------- |
| 类型 | **类注解**                         |
| 位置 | Rest风格开发的控制器增强类定义上方 |
| 作用 | 为Rest风格开发的控制器类做增强     |

- 范例：

```java
@RestControllerAdvice
public class ProjectExceptionAdvice {
}
```

::: tip 注意

此注解自带@ResponseBody注解与@Component注解，具备对应的功能

![1652602166184](/JavaCore/img/SpringMVC/SpringMVC-24.png)

:::

**知识点2：@ExceptionHandler**

| 名称 | **@ExceptionHandler**                                        |
| ---- | ------------------------------------------------------------ |
| 类型 | **方法注解**                                                 |
| 位置 | 专用于异常处理的控制器方法上方                               |
| 作用 | 设置指定异常的处理方案，功能等同于控制器方法，出现异常后终止原始控制器执行,并转入当前方法执行 |

- 范例：

```java
@RestControllerAdvice
public class ProjectExceptionAdvice {
    @ExceptionHandler(Exception.class)  //拦截异常
    public Result doException(Exception ex){
        System.out.println("出现异常");
        return new Result(400,null,"出现异常");
    }
}
```

### 6.4 **项目异常处理方案**

#### 6.4.1 **异常分类**

异常处理器我们已经能够使用了，那么在咱们的项目中该如何来处理异常呢?

因为异常的种类有很多，如果每一个异常都对应一个@ExceptionHandler，那得写多少个方法来处

理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类:

- 业务异常（BusinessException）

  - 规范的用户行为产生的异常

    - 用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串

    ![1652602442634](/JavaCore/img/SpringMVC/SpringMVC-25.png)

  - 不规范的用户行为操作产生的异常

    - 如用户故意传递错误数据

    ![1652602556504](/JavaCore/img/SpringMVC/SpringMVC-26.png)

- 系统异常（SystemException）

  - 项目运行过程中可预计但无法避免的异常
    -  比如数据库或服务器宕机

- 其他异常（Exception）

  - 编程人员未预期到的异常，如:用到的文件不存在

    ![1652602615472](/JavaCore/img/SpringMVC/SpringMVC-27.png)

将异常分类以后，针对不同类型的异常，要提供具体的解决方案:

#### 6.4.2 **异常解决方案**

- 业务异常（BusinessException）
  - 发送对应消息传递给用户，提醒规范操作
    - 大家常见的就是提示用户名已存在或密码格式不正确等

- 系统异常（SystemException）
  - 发送固定消息传递给用户，安抚用户
    - 系统繁忙，请稍后再试
    - 系统正在维护升级，请稍后再试
    - 系统出问题，请联系系统管理员等
  - 发送特定消息给运维人员，提醒维护
    - 可以发送短信、邮箱或者是公司内部通信软件
  - 记录日志
    - 发消息和记录日志对用户来说是不可见的，属于后台程序

- 其他异常（Exception）
  - 发送固定消息传递给用户，安抚用户
  - 发送特定消息给编程人员，提醒维护（纳入预期范围内）
    - 一般是程序没有考虑全，比如未做非空校验等
  - 记录日志

#### 6.4.3**异常解决方案的具体实现**

> 思路:
>
> 1.先通过自定义异常，完成BusinessException和SystemException的定义
>
> 2.将其他异常包装成自定义异常类型
>
> 3.在异常处理器类中对不同的异常进行处理

①：自定义项目系统级异常

```java
public class SystemException extends RuntimeException{

    private Integer code;

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }
    public SystemException(Integer code) {
        this.code = code;
    }
    public SystemException(Integer code,String message) {
        super(message);
        this.code = code;
    }
    public SystemException(Integer code,String message, Throwable cause ) {
        super(message, cause);
        this.code = code;
    }
}
```

②：自定义项目业务级异常

```java
public class BusinessException extends RuntimeException{
    private Integer code;

    public Integer getCode() {
        return code;
    }
    public void setCode(Integer code) {
        this.code = code;
    }
    public BusinessException(Integer code) {
        this.code = code;
    }

    public BusinessException(Integer code,String message) {
        super(message);
        this.code = code;
    }
    public BusinessException(Integer code,String message, Throwable cause ) {
        super(message, cause);
        this.code = code;
    }
}

```

③：自定义异常编码

```java
public class Code {
    public static final Integer System_ERR = 50001;
    public static final Integer System_TomeOut_ERR = 50002;
    public static final Integer System_Unknow_ERR = 50002;
    public static final Integer Business_ERR = 50002;
}
```

④：触发自定义异常

```java
    @GetMapping("{id}")
    public Book getById(@PathVariable Integer id){
        //模拟业务异常，包装成自定义异常
        if (id==1){
            throw new BusinessException(Code.Business_ERR,"请不要瞎搞噢~~");
        }
        try{
            int i=1/0;
        }catch (Exception e){
            throw new SystemException(Code.System_TomeOut_ERR,"服务器访问超时，请重试!",e);
        };
        return bookService.getById(id);
    }
```

⑤：拦截并处理异常

```java
//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器
@RestControllerAdvice
public class ProjectExceptionAdvice {
    //@ExceptionHandler用于设置当前处理器类对应的异常类型
    @ExceptionHandler(SystemException.class)
    public Result SystemException(SystemException ex){
        //记录日志
        //发送消息给运维
        //发送消息给开发人员
        return new Result(Code.System_ERR,null,ex.getMessage());
    }
    @ExceptionHandler(BusinessException.class)
    public Result BusinessException(BusinessException ex){
        return new Result(Code.Business_ERR,ex.getMessage());
    }
    //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常
    @ExceptionHandler(Exception.class)  //拦截异常
    public Result doException(Exception ex){
        //记录日志
        //发送消息给运维
        //发送消息给开发人员
        System.out.println("出现异常");
        return new Result(Code.System_Unknow_ERR,null,"系统繁忙，请稍后再试！");
    }
}
```

结果：；

![1652603871761](/JavaCore/img/SpringMVC/SpringMVC-28.png)


## 七、拦截器

### 7.1**拦截器概念**

讲解拦截器的概念之前，我们先看一张图:

![1652711328898](/JavaCore/img/SpringMVC/SpringMVC-29.png)

(1)浏览器发送一个请求会先到Tomcat的web服务器

(2)Tomcat服务器接收到请求以后，会去判断请求的是静态资源还是动态资源

(3)如果是静态资源，会直接到Tomcat的项目部署目录下去直接访问

(4)如果是动态资源，就需要交给项目的后台代码进行处理

(5)在找到具体的方法之前，我们可以去配置过滤器(可以配置多个)，按照顺序进行执行

(6)然后进入到到中央处理器(SpringMVC中的内容)，SpringMVC会根据配置的规则进行拦截

(7)如果满足规则，则进行处理，找到其对应的controller类中的方法进行执行,完成后返回结果

(8)如果不满足规则，则不进行处理

(9)这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现?

这个就是拦截器要做的事。

- **拦截器（Interceptor）**是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行

- **作用:**
  - 在指定的方法调用前后执行预先设定的代码
  - 阻止原始方法的执行
  - 总结：拦截器就是用来做增强

看完以后，大家会发现

- 拦截器和过滤器在作用和执行顺序上也很相似

所以这个时候，就有一个问题需要思考:**拦截器和过滤器之间的区别**是什么?

- 归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术

- 拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强

![1652711389877](/JavaCore/img/SpringMVC/SpringMVC-30.png)

### 7.2 **拦截器入门案例**

#### 7.2.1 拦截器开发

①：声明拦截器的bean，并实现HandlerInterceptor接口（注意：扫描加载bean）

```java
@Component
public class ProjectInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("perHandle...");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("perHandle...");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("perHandle...");
    }
}
```

②：定义配置类，继承WebMvcConfigurationSupport，实现addInterceptors方法（注意：扫描加载配置）

```java
@Configuration
public class SpringMvcSupprot extends WebMvcConfigurationSupport {
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        ·········
    }
}
```

③：添加拦截器并设定拦截的访问路径，路径可以通过可变参数设置多个

```java
@Configuration
public class SpringMvcSupprot extends WebMvcConfigurationSupport {
    @Autowired
    private ProjectInterceptor projectInterceptor;
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns("/books");
    }
}
```

#### 7.2.2 简化拦截器

```java
@Configuration
@ComponentScan({"com.yz.controller"})
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {

    @Autowired
    private ProjectInterceptor projectInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns("/books");
    }
}

```

#### 7.2.3 拦截器执行流程

![1652713128601](/JavaCore/img/SpringMVC/SpringMVC-31.png)

当有拦截器后，请求会先进入preHandle方法，

如果方法返回true，则放行继续执行后面的`handle[controller的方法]`和后面的方法

如果返回false，则直接跳过后面方法的执行。

### 7.3 拦截器参数

#### 7.3.1  **前置处理方法**

```java
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {	
        System.out.println("perHandle..."+header);
        return true;
    }
```

- 参数
  - request：请求对象
  - response：响应对象
  - handler：被调用的处理器对象，本质上是一个方法对象，对反射技术中的Method对象进行了再包装

使用request对象可以获取请求数据中的内容，如获取请求头的Content-Typ

```java
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String header = request.getHeader("Content-type");
        System.out.println("perHandle..."+header);
        return true;
    }
```

使用handler参数，可以获取方法的相关信息

```java
   @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String header = request.getHeader("Content-type");
        HandlerMethod hm = (HandlerMethod)handler;
        String name = hm.getMethod().getName();//可以获取方法的名称
        System.out.println("perHandle..."+header+name);
        return true;
    }
```

#### 7.3.2 **后置处理方法**

原始方法运行后运行，如果原始方法被拦截，则不执行

```java
 @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle...");
    }

```

前三个参数和上面的是一致的。

modelAndView:如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整

因为咱们现在都是返回json数据，所以该参数的使用率不高。

#### 7.3.3  **完成处理方法**

拦截器最后执行的方法，无论原始方法是否执行

```java
 @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion...");
    }
```

前三个参数与上面的是一致的。

ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理

因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高。

这三个方法中，最常用的是**preHandle**,在这个方法中可以通过返回值来决定是否要进行放行，我们

可以把业务逻辑放在该方法中，如果满足业务则返回true放行，不满足则返回false拦截。

### 7.4 **拦截器链配置**

目前，我们在项目中只添加了一个拦截器，如果有多个，该如何配置?配置多个后，执行顺序是什么?

#### 7.4.1 **配置多个拦截器**

**步骤1:创建拦截器类**

实现接口，并重写接口中的方法

```java
@Component
public class ProjectInterceptor2 implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        System.out.println("perHandle222...");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle222...");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion222...");
    }
}
```

**步骤2:配置拦截器类**

```java
@Configuration
public class SpringMvcSupprot extends WebMvcConfigurationSupport {
    @Autowired
    private ProjectInterceptor projectInterceptor;
 @Autowired
    private ProjectInterceptor2 projectInterceptor2;

    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns("/books");
        registry.addInterceptor(projectInterceptor2).addPathPatterns("/books");
    }
}
```

**步骤3:运行程序，观察顺序**

拦截器执行的顺序是和配置顺序有关。就和前面所提到的运维人员进入机房的案例，先进后出。

- 当配置多个拦截器时，形成拦截器链

- 拦截器链的运行顺序参照拦截器添加顺序为准

- 当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行

- 当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作

![1652714863229](/JavaCore/img/SpringMVC/SpringMVC-32.png)

preHandle：与配置顺序相同，必定运行

postHandle:与配置顺序相反，可能不运行

afterCompletion:与配置顺序相反，可能不运行。

这个顺序不太好记，最终只需要把握住一个原则即可:**以最终的运行结果为准**


