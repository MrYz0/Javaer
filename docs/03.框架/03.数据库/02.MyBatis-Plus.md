---
title: MyBatis-Plus
date: 2022-07-21 09:19:34
permalink: /frame/MyBatis-Plus/
categories:
  - 框架
  - 数据库
tags:
  - 
author: 
  name: 杨洲
  link: https://github.com/xugaoyi
---

# MyBatis-Plus

## 学习内容

![MyBatis-Plus](/JavaCore/img/MyBatisPlus/MyBatis-Plus-1.png)

## 一、MyBatis-Plus简介

### **1**、简介

**MyBatis-Plus**（简称 MP）是一个 **MyBatis**的增强工具**，在 MyBatis 的基础上**只做**增强不做改变**，为

**简化开发、提高效率而生**。

> 愿景
>
> 我们的愿景是成为 MyBatis 最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。

![1652800786894](/JavaCore/img/MyBatisPlus/MyBatis-Plus-2.png)

### 2、特性

- **无侵入**：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑
- **损耗小**：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作
- **强大的 CRUD 操作**：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求
- **支持 Lambda 形式调用**：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错
- **支持主键自动生成**：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题
- **支持 ActiveRecord 模式**：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作
- **支持自定义全局通用操作**：支持全局通用方法注入（ Write once, use anywhere ）
- **内置代码生成器**：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用
- **内置分页插件**：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询
- **分页插件支持多种数据库**：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库
- **内置性能分析插件**：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询
- **内置全局拦截插件**：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作

### 3、支持数据库

> 任何能使用 `MyBatis` 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。

- MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb
- 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库

### 4、框架结构

![1652800861765](/JavaCore/img/MyBatisPlus/MyBatis-Plus-3.png)

### **5**、代码及文档地址

官方地址: [http://mp.baomidou.com](http://mp.baomidou.com )

代码发布地址:

Github: [https://github.com/baomidou/mybatis-plus](https://github.com/baomidou/mybatis-plus )

Gitee: [https://gitee.com/baomidou/mybatis-plus](https://gitee.com/baomidou/mybatis-plus )

文档发布地址: [https://baomidou.com/pages/24112f](https://baomidou.com/pages/24112f)

## 二、入门案例

### 1、开发环境

> IDE:2022.1
>
> JDK:JDK8+
>
> 构建工具：maven 3.5.4
>
> MySQL版本：MySQL 5.7
>
> Spring Boot：2.6.3
>
> MyBatis-Plus：3.5.1

### 2、创建数据库及表

#### a>创建表

```mysql
CREATE DATABASE `mybatis_plus` /*!40100 DEFAULT CHARACTER SET utf8mb4 */; use `mybatis_plus`; 
CREATE TABLE `user` ( 
    `id` bigint(20) NOT NULL COMMENT '主键ID',
    `name` varchar(30) DEFAULT NULL COMMENT '姓名',
    `age` int(11) DEFAULT NULL COMMENT '年龄', 
    `email` varchar(50) DEFAULT NULL COMMENT '邮箱', 
    PRIMARY KEY (`id`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

#### b>添加数据

```mysql
INSERT INTO user (id, name, age, email) VALUES 
(1, 'Jone', 18, 'test1@baomidou.com'), 
(2, 'Jack', 20, 'test2@baomidou.com'), 
(3, 'Tom', 28, 'test3@baomidou.com'), 
(4, 'Sandy', 21, 'test4@baomidou.com'), 
(5, 'Billie', 24, 'test5@baomidou.com');
```

### 3、创建springboot工程

#### **a>初始化工程**

使用 Spring Initializr 快速初始化一个 Spring Boot 工程

#### **b>引入依赖**

```xml
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<!--mybatis-->
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>2.2.2</version>
		</dependency>
		<!--mybatis-plus-->
		<dependency>
			<groupId>com.baomidou</groupId>
			<artifactId>mybatis-plus-boot-starter</artifactId>
			<version>3.5.1</version> </dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<!--MySQL-->
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
```

### 4、编写代码

#### a>配置application.yml

```yml
spring: 
	# 配置数据源信息 
	datasource: 
		# 配置数据源类型 
		type: com.zaxxer.hikari.HikariDataSource 
		# 配置连接数据库信息 
		driver-class-name: com.mysql.cj.jdbc.Driver 
		url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf- 8&useSSL=false 
		username: root 
		password: 123456
```

::: tip **注意：**

**1、驱动类driver-class-name**

spring boot 2.0（内置jdbc5驱动），驱动类使用：

driver-class-name: com.mysql.jdbc.Driver

spring boot 2.1及以上（内置jdbc8驱动），驱动类使用：

driver-class-name: com.mysql.cj.jdbc.Driver

否则运行测试用例的时候会有 WARN 信息

**2、连接地址url**

MySQL5.7版本的url：

jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&useSSL=false

MySQL8.0版本的url：

jdbc:mysql://localhost:3306/mybatis_plus?

serverTimezone=GMT%2B8&characterEncoding=utf-8&useSSL=false

否则运行测试用例报告如下错误：

java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or

represents more

:::

#### b>启动类

> 在Spring Boot启动类中添加@MapperScan注解，扫描mapper包

```java
@SpringBootApplication
@ComponentScan("com.yz.mybatisplus.mapper")
public class MPApplication {

	public static void main(String[] args) {
		SpringApplication.run(MPApplication.class, args);
	}

}
```

#### c>添加实体

#### d>添加mapper

```java
public interface UserMapper extends BaseMapper<User> {
}
```

#### e>测试

```java
//测试类
@SpringBootTest
public class MybatisPlusTest {
    @Autowired
    private UserMapper userMapper;


    @Test
    public void testSelectList(){
        //selectList()根据MP内置的条件构造器查询一个list集合，null表示没有条件，即查询所有
        userMapper.selectList(null).forEach(System.out::println);
    }
}
```

::: tip 注意

> IDEA在 userMapper 处报错，因为找不到注入的对象，因为类是动态创建的，但是程序可以正确
>
> 的执行。
>
> 为了避免报错，可以在mapper接口上添加 @Repository 注解

:::

#### **f>添加日志**

在application.yml中配置日志输出

```xml
# 配置MyBatis日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

![1652802671117](/JavaCore/img/MyBatisPlus/MyBatis-Plus-4.png)

## 三、基本CRUD

::: details CRUD补充知识

什么是CRUD？
**CRUD是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。主要被用在描述软件系统中DataBase或者持久层的基本操作功能。**

:::

### 1、BaseMapper

MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，我们可以直接使用，接口如
下：

::: details BaseMapper

```java
public interface BaseMapper<T> extends Mapper<T> {

    /**
     * 插入一条记录
     *
     * @param entity 实体对象
     */
    int insert(T entity);

    /**
     * 根据 ID 删除
     *
     * @param id 主键ID
     */
    int deleteById(Serializable id);

    /**
     * 根据实体(ID)删除
     *
     * @param entity 实体对象
     * @since 3.4.4
     */
    int deleteById(T entity);

    /**
     * 根据 columnMap 条件，删除记录
     *
     * @param columnMap 表字段 map 对象
     */
    int deleteByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);

    /**
     * 根据 entity 条件，删除记录
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
     */
    int delete(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

    /**
     * 删除（根据ID或实体 批量删除）
     *
     * @param idList 主键ID列表或实体列表(不能为 null 以及 empty)
     */
    int deleteBatchIds(@Param(Constants.COLLECTION) Collection<?> idList);

    /**
     * 根据 ID 修改
     *
     * @param entity 实体对象
     */
    int updateById(@Param(Constants.ENTITY) T entity);

    /**
     * 根据 whereEntity 条件，更新记录
     *
     * @param entity        实体对象 (set 条件值,可以为 null)
     * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
     */
    int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper<T> updateWrapper);

    /**
     * 根据 ID 查询
     *
     * @param id 主键ID
     */
    T selectById(Serializable id);

    /**
     * 查询（根据ID 批量查询）
     *
     * @param idList 主键ID列表(不能为 null 以及 empty)
     */
    List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);

    /**
     * 查询（根据 columnMap 条件）
     *
     * @param columnMap 表字段 map 对象
     */
    List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);

    /**
     * 根据 entity 条件，查询一条记录
     * <p>查询一条记录，例如 qw.last("limit 1") 限制取一条记录, 注意：多条数据会报异常</p>
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    default T selectOne(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper) {
        List<T> ts = this.selectList(queryWrapper);
        if (CollectionUtils.isNotEmpty(ts)) {
            if (ts.size() != 1) {
                throw ExceptionUtils.mpe("One record is expected, but the query result is multiple records");
            }
            return ts.get(0);
        }
        return null;
    }

    /**
     * 根据 Wrapper 条件，判断是否存在记录
     *
     * @param queryWrapper 实体对象封装操作类
     * @return
     */
    default boolean exists(Wrapper<T> queryWrapper) {
        Long count = this.selectCount(queryWrapper);
        return null != count && count > 0;
    }

    /**
     * 根据 Wrapper 条件，查询总记录数
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    Long selectCount(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

    /**
     * 根据 entity 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

    /**
     * 根据 Wrapper 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    List<Map<String, Object>> selectMaps(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

    /**
     * 根据 Wrapper 条件，查询全部记录
     * <p>注意： 只返回第一个字段的值</p>
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    List<Object> selectObjs(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

    /**
     * 根据 entity 条件，查询全部记录（并翻页）
     *
     * @param page         分页查询条件（可以为 RowBounds.DEFAULT）
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    <P extends IPage<T>> P selectPage(P page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

    /**
     * 根据 Wrapper 条件，查询全部记录（并翻页）
     *
     * @param page         分页查询条件
     * @param queryWrapper 实体对象封装操作类
     */
    <P extends IPage<Map<String, Object>>> P selectMapsPage(P page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
}
```
:::

### 2、新增

::: tip 新增

```java
  /**
     * 插入一条记录
     *
     * @param entity 实体对象
     */
    int insert(T entity);
```

:::

```java
@Test
    public void testInsert(){
        User user=new User();
        user.setName("杨洲");
        user.setAge(20);
        user.setEmail("256@qq.com");
        int insert = userMapper.insert(user);
        System.out.println(insert);
        System.out.println(user.getId());
    }
```

> 最终执行的结果，所获取的id为1528566126684606465
> 这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id

![1653273711699](/JavaCore/img/MyBatisPlus/MyBatis-Plus-5.png)

### 3、删除

::: tip 删除

有三种:**通过id删除单个、通过id批量删除、通过map条件删除记录**

```java
    /** 
     * 根据 ID 删除
     *
     * @param id 主键ID
     */
    int deleteById(Serializable id);

    /**
     * 根据实体(ID)删除
     *
     * @param entity 实体对象
     * @since 3.4.4
     */
    int deleteById(T entity);

    /**
     * 根据 columnMap 条件，删除记录
     *
     * @param columnMap 表字段 map 对象
     */
    int deleteByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);

    /**
     * 根据 entity 条件，删除记录
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
     */
    int delete(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

    /**
     * 删除（根据ID或实体 批量删除）
     *
     * @param idList 主键ID列表或实体列表(不能为 null 以及 empty)
     */
    int deleteBatchIds(@Param(Constants.COLLECTION) Collection<?> idList);
```

:::

#### a>通过id删除记录

```java
 public void testDelete(){
        //第一种删除
       int deleteById = userMapper.deleteById(1528566126684606465L);
       System.out.println(deleteById);
    }
```

![1653275762988](/JavaCore/img/MyBatisPlus/MyBatis-Plus-6.png)

#### b>通过id批量删除记录

```java
 public void testDelete(){
      List<Long> asList = Arrays.asList(1L, 2L, 3L);
        int deleteBatchIds = userMapper.deleteBatchIds(asList);
        System.out.println(deleteBatchIds);
    }
```

![1653275866285](/JavaCore/img/MyBatisPlus/MyBatis-Plus-7.png)

#### c>通过map条件删除记录

```java
 public void testDelete(){
        Map<String,Object> map = new HashMap<>();
        map.put("name","yz");
        map.put("age",20);
        int deleteByMap = userMapper.deleteByMap(map);
        System.out.println(deleteByMap);
    }
```

![1653275808278](/JavaCore/img/MyBatisPlus/MyBatis-Plus-8.png)

### 4、修改

::: tip 修改

```java
    /**
     * 根据 ID 修改
     *
     * @param entity 实体对象
     */
    int updateById(@Param(Constants.ENTITY) T entity);

    /**
     * 根据 whereEntity 条件，更新记录
     *
     * @param entity        实体对象 (set 条件值,可以为 null)
     * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
     */
    int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper<T> updateWrapper);
```

:::

```java
    @Test
    public void testUpdate(){
        //修改用户信息
        //SQL:UPDATE user SET name=?, age=?, email=? WHERE id=?
        User user=new User();
        user.setId(4L);
        user.setName("杨洲");
        user.setAge(20);
        user.setEmail("256@qq.com");
        int updateById = userMapper.updateById(user);
        System.out.println(updateById);
    }
```

![1653276109949](/JavaCore/img/MyBatisPlus/MyBatis-Plus-9.png)

### 5、查询

::: tip 查询

```java
    /**
     * 根据 ID 查询
     *
     * @param id 主键ID
     */
    T selectById(Serializable id);

    /**
     * 查询（根据ID 批量查询）
     *
     * @param idList 主键ID列表(不能为 null 以及 empty)
     */
    List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);

    /**
     * 查询（根据 columnMap 条件）
     *
     * @param columnMap 表字段 map 对象
     */
    List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);
```

:::

#### a>根据id查询用户信息

```java
public void testSelect(){
        //根据ID查询用户信息
        //第一种方法
        //SQL：SELECT id,name,age,email FROM user WHERE id=?
		 User selectById = userMapper.selectById(4L);	
         System.out.println(selectById);
}
```

![1653276495046](/JavaCore/img/MyBatisPlus/MyBatis-Plus-10.png)

#### b>根据id批量查询用户

```java
@Test
public void testSelect(){
        //第二种方法
        //SQL:SELECT id,name,age,email FROM user WHERE id IN ( ? , ? )
       List<Long> longList = Arrays.asList(4L, 5L);
        List<User> users = userMapper.selectBatchIds(longList);
        for (User user:users
             ) {
            System.out.println(user);
        }
    }        
```

![1653276573615](/JavaCore/img/MyBatisPlus/MyBatis-Plus-11.png)

#### c>通过map条件查询用户信息

```java
@Test
public void testSelect(){
        //第三种
        //SQL:SELECT id,name,age,email FROM user WHERE name = ? AND age = ?
        //根据map中的条件查询用户信息
        Map<String, Object> map = new HashMap<>();
        map.put("name","yz");
        map.put("age",20);
        List<User> selectByMap = userMapper.selectByMap(map);
        System.out.println(selectByMap);
    }        
```

![1653276770566](/JavaCore/img/MyBatisPlus/MyBatis-Plus-12.png)

#### d>查询所有数据

```java
@Test
public void testSelect(){
        //第三种方法
        //SQL:SELECT id,name,age,email FROM user
    	List<User> userList = userMapper.selectList(null);
        System.out.println(userList);
    }        
```

![1653276632994](/JavaCore/img/MyBatisPlus/MyBatis-Plus-13.png)

::: info 总结

> 通过观察BaseMapper中的方法，大多方法中都有Wrapper类型的形参，此为条件构造器，可针
> 对于SQL语句设置不同的条件，若没有条件，则可以为该形参赋值null，即查询（删除/修改）所
> 有数据

:::

### 6、用Service

> 说明:
>
> - 通用 Service CRUD 封装[IService (opens new window)](https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java)接口，进一步封装 CRUD 采用 `get 查询单行` `remove 删除` `list 查询集合` `page 分页` 前缀命名方式区分 `Mapper` 层避免混淆，
> - 泛型 `T` 为任意实体对象
> - 建议如果存在自定义通用 Service 方法的可能，请创建自己的 `IBaseService` 继承 `Mybatis-Plus` 提供的基类
> - 对象 `Wrapper` 为 [条件构造器](https://baomidou.com/01.指南/02.核心功能/wrapper.html)

#### a>IService

MyBatis-Plus中有一个接口IService和其实现类ServiceImpl，封装了常见的业务层逻辑

::: details IService详情

```java
public interface IService<T> {

    /**
     * 默认批次提交数量
     */
    int DEFAULT_BATCH_SIZE = 1000;

    /**
     * 插入一条记录（选择字段，策略插入）
     *
     * @param entity 实体对象
     */
    default boolean save(T entity) {
        return SqlHelper.retBool(getBaseMapper().insert(entity));
    }

    /**
     * 插入（批量）
     *
     * @param entityList 实体对象集合
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean saveBatch(Collection<T> entityList) {
        return saveBatch(entityList, DEFAULT_BATCH_SIZE);
    }

    /**
     * 插入（批量）
     *
     * @param entityList 实体对象集合
     * @param batchSize  插入批次数量
     */
    boolean saveBatch(Collection<T> entityList, int batchSize);

    /**
     * 批量修改插入
     *
     * @param entityList 实体对象集合
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean saveOrUpdateBatch(Collection<T> entityList) {
        return saveOrUpdateBatch(entityList, DEFAULT_BATCH_SIZE);
    }

    /**
     * 批量修改插入
     *
     * @param entityList 实体对象集合
     * @param batchSize  每次的数量
     */
    boolean saveOrUpdateBatch(Collection<T> entityList, int batchSize);

    /**
     * 根据 ID 删除
     *
     * @param id 主键ID
     */
    default boolean removeById(Serializable id) {
        return SqlHelper.retBool(getBaseMapper().deleteById(id));
    }

    /**
     * 根据 ID 删除
     *
     * @param id      主键(类型必须与实体类型字段保持一致)
     * @param useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    default boolean removeById(Serializable id, boolean useFill) {
        throw new UnsupportedOperationException("不支持的方法!");
    }

    /**
     * 根据实体(ID)删除
     *
     * @param entity 实体
     * @since 3.4.4
     */
    default boolean removeById(T entity) {
        return SqlHelper.retBool(getBaseMapper().deleteById(entity));
    }

    /**
     * 根据 columnMap 条件，删除记录
     *
     * @param columnMap 表字段 map 对象
     */
    default boolean removeByMap(Map<String, Object> columnMap) {
        Assert.notEmpty(columnMap, "error: columnMap must not be empty");
        return SqlHelper.retBool(getBaseMapper().deleteByMap(columnMap));
    }

    /**
     * 根据 entity 条件，删除记录
     *
     * @param queryWrapper 实体包装类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default boolean remove(Wrapper<T> queryWrapper) {
        return SqlHelper.retBool(getBaseMapper().delete(queryWrapper));
    }

    /**
     * 删除（根据ID 批量删除）
     *
     * @param list 主键ID或实体列表
     */
    default boolean removeByIds(Collection<?> list) {
        if (CollectionUtils.isEmpty(list)) {
            return false;
        }
        return SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));
    }

    /**
     * 批量删除
     *
     * @param list    主键ID或实体列表
     * @param useFill 是否填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean removeByIds(Collection<?> list, boolean useFill) {
        if (CollectionUtils.isEmpty(list)) {
            return false;
        }
        if (useFill) {
            return removeBatchByIds(list, true);
        }
        return SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));
    }

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list 主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)
     * @return 删除结果
     * @since 3.5.0
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean removeBatchByIds(Collection<?> list) {
        return removeBatchByIds(list, DEFAULT_BATCH_SIZE);
    }

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list    主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)
     * @param useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean removeBatchByIds(Collection<?> list, boolean useFill) {
        return removeBatchByIds(list, DEFAULT_BATCH_SIZE, useFill);
    }

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list      主键ID或实体列表
     * @param batchSize 批次大小
     * @return 删除结果
     * @since 3.5.0
     */
    default boolean removeBatchByIds(Collection<?> list, int batchSize) {
        throw new UnsupportedOperationException("不支持的方法!");
    }

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list      主键ID或实体列表
     * @param batchSize 批次大小
     * @param useFill   是否启用填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    default boolean removeBatchByIds(Collection<?> list, int batchSize, boolean useFill) {
        throw new UnsupportedOperationException("不支持的方法!");
    }

    /**
     * 根据 ID 选择修改
     *
     * @param entity 实体对象
     */
    default boolean updateById(T entity) {
        return SqlHelper.retBool(getBaseMapper().updateById(entity));
    }

    /**
     * 根据 UpdateWrapper 条件，更新记录 需要设置sqlset
     *
     * @param updateWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper}
     */
    default boolean update(Wrapper<T> updateWrapper) {
        return update(null, updateWrapper);
    }

    /**
     * 根据 whereEntity 条件，更新记录
     *
     * @param entity        实体对象
     * @param updateWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper}
     */
    default boolean update(T entity, Wrapper<T> updateWrapper) {
        return SqlHelper.retBool(getBaseMapper().update(entity, updateWrapper));
    }

    /**
     * 根据ID 批量更新
     *
     * @param entityList 实体对象集合
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean updateBatchById(Collection<T> entityList) {
        return updateBatchById(entityList, DEFAULT_BATCH_SIZE);
    }

    /**
     * 根据ID 批量更新
     *
     * @param entityList 实体对象集合
     * @param batchSize  更新批次数量
     */
    boolean updateBatchById(Collection<T> entityList, int batchSize);

    /**
     * TableId 注解存在更新记录，否插入一条记录
     *
     * @param entity 实体对象
     */
    boolean saveOrUpdate(T entity);

    /**
     * 根据 ID 查询
     *
     * @param id 主键ID
     */
    default T getById(Serializable id) {
        return getBaseMapper().selectById(id);
    }

    /**
     * 查询（根据ID 批量查询）
     *
     * @param idList 主键ID列表
     */
    default List<T> listByIds(Collection<? extends Serializable> idList) {
        return getBaseMapper().selectBatchIds(idList);
    }

    /**
     * 查询（根据 columnMap 条件）
     *
     * @param columnMap 表字段 map 对象
     */
    default List<T> listByMap(Map<String, Object> columnMap) {
        return getBaseMapper().selectByMap(columnMap);
    }

    /**
     * 根据 Wrapper，查询一条记录 <br/>
     * <p>结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")</p>
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default T getOne(Wrapper<T> queryWrapper) {
        return getOne(queryWrapper, true);
    }

    /**
     * 根据 Wrapper，查询一条记录
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     * @param throwEx      有多个 result 是否抛出异常
     */
    T getOne(Wrapper<T> queryWrapper, boolean throwEx);

    /**
     * 根据 Wrapper，查询一条记录
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    Map<String, Object> getMap(Wrapper<T> queryWrapper);

    /**
     * 根据 Wrapper，查询一条记录
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     * @param mapper       转换函数
     */
    <V> V getObj(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);

    /**
     * 查询总记录数
     *
     * @see Wrappers#emptyWrapper()
     */
    default long count() {
        return count(Wrappers.emptyWrapper());
    }

    /**
     * 根据 Wrapper 条件，查询总记录数
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default long count(Wrapper<T> queryWrapper) {
        return SqlHelper.retCount(getBaseMapper().selectCount(queryWrapper));
    }

    /**
     * 查询列表
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default List<T> list(Wrapper<T> queryWrapper) {
        return getBaseMapper().selectList(queryWrapper);
    }

    /**
     * 查询所有
     *
     * @see Wrappers#emptyWrapper()
     */
    default List<T> list() {
        return list(Wrappers.emptyWrapper());
    }

    /**
     * 翻页查询
     *
     * @param page         翻页对象
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default <E extends IPage<T>> E page(E page, Wrapper<T> queryWrapper) {
        return getBaseMapper().selectPage(page, queryWrapper);
    }

    /**
     * 无条件翻页查询
     *
     * @param page 翻页对象
     * @see Wrappers#emptyWrapper()
     */
    default <E extends IPage<T>> E page(E page) {
        return page(page, Wrappers.emptyWrapper());
    }

    /**
     * 查询列表
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default List<Map<String, Object>> listMaps(Wrapper<T> queryWrapper) {
        return getBaseMapper().selectMaps(queryWrapper);
    }

    /**
     * 查询所有列表
     *
     * @see Wrappers#emptyWrapper()
     */
    default List<Map<String, Object>> listMaps() {
        return listMaps(Wrappers.emptyWrapper());
    }

    /**
     * 查询全部记录
     */
    default List<Object> listObjs() {
        return listObjs(Function.identity());
    }

    /**
     * 查询全部记录
     *
     * @param mapper 转换函数
     */
    default <V> List<V> listObjs(Function<? super Object, V> mapper) {
        return listObjs(Wrappers.emptyWrapper(), mapper);
    }

    /**
     * 根据 Wrapper 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default List<Object> listObjs(Wrapper<T> queryWrapper) {
        return listObjs(queryWrapper, Function.identity());
    }

    /**
     * 根据 Wrapper 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     * @param mapper       转换函数
     */
    default <V> List<V> listObjs(Wrapper<T> queryWrapper, Function<? super Object, V> mapper) {
        return getBaseMapper().selectObjs(queryWrapper).stream().filter(Objects::nonNull).map(mapper).collect(Collectors.toList());
    }

    /**
     * 翻页查询
     *
     * @param page         翻页对象
     * @param queryWrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper}
     */
    default <E extends IPage<Map<String, Object>>> E pageMaps(E page, Wrapper<T> queryWrapper) {
        return getBaseMapper().selectMapsPage(page, queryWrapper);
    }

    /**
     * 无条件翻页查询
     *
     * @param page 翻页对象
     * @see Wrappers#emptyWrapper()
     */
    default <E extends IPage<Map<String, Object>>> E pageMaps(E page) {
        return pageMaps(page, Wrappers.emptyWrapper());
    }

    /**
     * 获取对应 entity 的 BaseMapper
     *
     * @return BaseMapper
     */
    BaseMapper<T> getBaseMapper();

    /**
     * 获取 entity 的 class
     *
     * @return {@link Class<T>}
     */
    Class<T> getEntityClass();

    /**
     * 以下的方法使用介绍:
     *
     * 一. 名称介绍
     * 1. 方法名带有 query 的为对数据的查询操作, 方法名带有 update 的为对数据的修改操作
     * 2. 方法名带有 lambda 的为内部方法入参 column 支持函数式的
     * 二. 支持介绍
     *
     * 1. 方法名带有 query 的支持以 {@link ChainQuery} 内部的方法名结尾进行数据查询操作
     * 2. 方法名带有 update 的支持以 {@link ChainUpdate} 内部的方法名为结尾进行数据修改操作
     *
     * 三. 使用示例,只用不带 lambda 的方法各展示一个例子,其他类推
     * 1. 根据条件获取一条数据: `query().eq("column", value).one()`
     * 2. 根据条件删除一条数据: `update().eq("column", value).remove()`
     *
     */

    /**
     * 链式查询 普通
     *
     * @return QueryWrapper 的包装类
     */
    default QueryChainWrapper<T> query() {
        return ChainWrappers.queryChain(getBaseMapper());
    }

    /**
     * 链式查询 lambda 式
     * <p>注意：不支持 Kotlin </p>
     *
     * @return LambdaQueryWrapper 的包装类
     */
    default LambdaQueryChainWrapper<T> lambdaQuery() {
        return ChainWrappers.lambdaQueryChain(getBaseMapper());
    }

    /**
     * 链式查询 lambda 式
     * kotlin 使用
     *
     * @return KtQueryWrapper 的包装类
     */
    default KtQueryChainWrapper<T> ktQuery() {
        return ChainWrappers.ktQueryChain(getBaseMapper(), getEntityClass());
    }

    /**
     * 链式查询 lambda 式
     * kotlin 使用
     *
     * @return KtQueryWrapper 的包装类
     */
    default KtUpdateChainWrapper<T> ktUpdate() {
        return ChainWrappers.ktUpdateChain(getBaseMapper(), getEntityClass());
    }

    /**
     * 链式更改 普通
     *
     * @return UpdateWrapper 的包装类
     */
    default UpdateChainWrapper<T> update() {
        return ChainWrappers.updateChain(getBaseMapper());
    }

    /**
     * 链式更改 lambda 式
     * <p>注意：不支持 Kotlin </p>
     *
     * @return LambdaUpdateWrapper 的包装类
     */
    default LambdaUpdateChainWrapper<T> lambdaUpdate() {
        return ChainWrappers.lambdaUpdateChain(getBaseMapper());
    }

    /**
     * <p>
     * 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法
     * 此次修改主要是减少了此项业务代码的代码量（存在性验证之后的saveOrUpdate操作）
     * </p>
     *
     * @param entity 实体对象
     */
    default boolean saveOrUpdate(T entity, Wrapper<T> updateWrapper) {
        return update(entity, updateWrapper) || saveOrUpdate(entity);
    }
}
```

:::

#### b>创建Service接口和实现类

```java
//Service接口
//UserService继承IService模板提供的基础功能
public interface UserService extends IService<User> {
}
```

```java
//实现类
//ServiceImpl实现了IService，提供了IService中基础功能的实现
//若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
}
```

#### c>测试查询记录数

```java
    @Test
    public void testGetCount(){
        //查询总记录数
        long count = userService.count();
        System.out.println("总记录数"+count);
    }
```

![1653278414700](/JavaCore/img/MyBatisPlus/MyBatis-Plus-14.png)

#### d>测试批量插入

```java
    @Test
    public void insertMore(){
        User user1=new User();
        user1.setName("杨洲");
        user1.setAge(21);
        user1.setEmail("232");
        User user2=new User();
        user2.setName("杨洲");
        user2.setAge(21);
        user2.setEmail("232");
        List<User> userList = Arrays.asList(user1, user2);
        boolean saveBatch = userService.saveBatch(userList);
        System.out.println(saveBatch);
    }
```

![1653278383808](/JavaCore/img/MyBatisPlus/MyBatis-Plus-15.png)

## 四、常用注解

### 1、@TableName

经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在

**Mapper接口继承BaseMapper**时，**设置了泛型User，而操作的表为user表**

由此得出结论，MyBatis-Plus在**确定操作的表**时，**由BaseMapper的泛型决定**，即实体类型决

定，且**默认操作的表名和实体类型的类名一致**

#### a>问题

若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？

我们将表user更名为t_user，测试查询功能

程序抛出异常，**Table 'mybatis_plus.user' doesn't exist**，因为现在的表名为t_user，而默认操作

的表名和实体类型的类名一致，即user表

![1653291589254](/JavaCore/img/MyBatisPlus/MyBatis-Plus-16.png)

#### b>通过@TableName 解决问题

在实体类类型上添加**@TableName("t_user")**，标识实体类对应的表，即可成功执行SQL语句

![1653291610273](/JavaCore/img/MyBatisPlus/MyBatis-Plus-17.png)

#### c>通过全局配置解决问题

在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如t_或tbl_

此时，可以使用**MyBatis-Plus提供的全局配置**，为实体类所对应的表名设置默认的前缀，那么就

不需要在每个实体类上通过**@TableName标识实体类对应的表**

```yml
mybatis-plus:
  configuration:
    # 配置MyBatis日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  # 设置MyBatis-Plus的全局配置
  global-config:
    db-config:
      # 设置实体类所对应的表的统一前缀
      table-prefix: t_
```

### 2、@Tableld

经过以上的测试，**MyBatis-Plus在实现CRUD时，会默认将id作为主键列**，并在插入数据时，**默认**

**基于雪花算法的策略生成id**

#### a>问题

若实体类和表中表示**主键的不是id，而是其他字段**，例如uid，MyBatis-Plus会自动识别uid为主

键列吗？

我们实体类中的属性id改为uid，将表中的字段id也改为uid，测试添加功能



程序抛出异常，**Field 'uid' doesn't have a default value**，说明MyBatis-Plus没有将uid作为主键

赋值

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-18.png)

#### **b>通过@TableId解决问题**

在实体类中uid属性上通过**@TableId**将其标识为主键，即可成功执行SQL语句

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-19.png)

#### **c>@TableId的value属性**

若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解

**@TableId**，则抛出异常**Unknown column 'id' in 'field list'**，即MyBatis-Plus仍然会将id作为表的

主键操作，而表中表示主键的是字段uid

此时需要通过**@TableId注解的value属性，指定表中的主键字段**，@TableId("uid")或

**@TableId(value="uid")**

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-20.png)

#### d>@Tableld的type属性

type属性用来定义主键策略

#### 常用的主键策略：

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-21.png)

#### 配置全局主键策略：

```yml
# 加入日志功能
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  # 设置MyBatis-Plus的全局配置
  global-config:
    db-config:
      # 设置实体类所对应的表的统一前缀
      table-prefix: t_
      # 设置统一的主键生成策略
      id-type: auto
```

::: details 雪花算法

#### - 背景

需要选择合适的方案去应对数据规模的增长，以应对**逐渐增长的访问压力和数据量**。

数据库的扩展方式主要包括：业务分库、主从复制，数据库分表。

#### - 数据库分表

将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务

继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，

如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进

行拆分。

单表数据拆分有两种方式：**垂直分表和水平分表**。示意图如下：

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-22.png)

##### - 垂直分表

垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。

例如，前面示意图中的 nickname 和 description 字段，假设我们是一个婚恋网站，用户在筛选其他用

户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展

示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外

一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升。

##### - 水平分表

水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以

作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000

万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表。

但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性

能瓶颈或者隐患。

水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处

**主键自增**

①以最常见的用户 ID 为例，可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到表 1中，

1000000 ~ 1999999 放到表2中，以此类推。

②**复杂点**：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会

导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适

的分段大小。

③**优点**：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，

只需要增加新的表就可以了，原有的数据不需要动。

④**缺点**：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而

另外一个分段实际存储的数据量有 1000 万条。

**取模**

①同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，可以简单地用 user_id % 10 的值来

表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号

为 6 的子表中。

②**复杂点**：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。

③**优点**：表分布比较均匀。

④**缺点**：扩充新的表很麻烦，所有数据都要重分布。

**雪花算法**

雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的

主键的有序性。

①**核心思想：**

长度共64bit（一个long型）。

首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负

数是1，所以id一般是正数，最高位是0。

41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。

10bit作为机器的ID（

5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。

12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-23.png)

②**优点**：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。

:::



### 3、@TableField

经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致

如果**实体类中的属性名和字段名不一致的情况**，会出现什么问题呢？

#### a>情况1

若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格

例如实体类属性userName，表中字段user_name

此时**MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格**

相当于在MyBatis中配置

#### a>情况2

若实体类中的属性和表中的字段不满足情况1

例如实体类属性name，表中字段username

此时需要在实体类属性上使用**@TableField("username")**设置**属性所对应的字段名**

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-24.png)

### 4、@TableLogic

#### a>逻辑删除

- 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据
- **逻辑删除**：假删除，**将对应数据中代表是否被删除字段的状态修改为“被删除状态”**，之后在数据库

中仍旧能看到此条数据记录

- 使用场景：可以进行数据恢复

#### b>实现逻辑删除

**step1：**数据库中创建逻辑删除状态列，设置默认值为0

![1653297804138](/JavaCore/img/MyBatisPlus/MyBatis-Plus-25.png)

**step2：**实体类中添加逻辑删除属性

![img](/JavaCore/img/MyBatisPlus/MyBatis-Plus-26.png)

> **step3：测试**
>
> 测试删除功能，真正执行的是修改
>
> **UPDATE t_user SET is_deleted=1 WHERE id=? AND is_deleted=0**
>
> 测试查询功能，被逻辑删除的数据默认不会被查询
>
> **SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0**

## 五、条件构造器和常用接口

### 1、wapper介绍

![1653297882698](/JavaCore/img/MyBatisPlus/MyBatis-Plus-27.png)

> Wrapper ： **条件构造抽象类**，最顶端父类
>
> - AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件
>
> - - QueryWrapper ： 查询条件封装
>   - UpdateWrapper ： Update 条件封装
>   - AbstractLambdaWrapper ： 使用Lambda 语法
>
> - - - LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper
>     - LambdaUpdateWrapper ： Lambda 更新封装Wrapper

### 2、QueryWrapper

#### a>例1：组装查询条件

```java
    @Test
    public void test01(){
        //查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息
        QueryWrapper<User> queryWrapper=new QueryWrapper<>();
        QueryWrapper<User> between = queryWrapper.like("user_name", "杨洲")
                .between("age", 20, 30)
                .isNotNull("email");;
        List<User> userList = userMapper.selectList(between);
        userList.forEach(System.out::println);
    }
```

![1653298847740](/JavaCore/img/MyBatisPlus/MyBatis-Plus-28.png)

#### b>例2：组装排序条件

```java
    @Test
    public void test02(){
        //查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序
        QueryWrapper<User> queryWrapper=new QueryWrapper<>();
        QueryWrapper<User> userQueryWrapper = queryWrapper.orderByDesc("age").orderByAsc("uid");
        List<User> userList = userMapper.selectList(userQueryWrapper);
        userList.forEach(System.out::println);
    }
```

![1653299177925](/JavaCore/img/MyBatisPlus/MyBatis-Plus-29.png)

#### c>例3：组装删除条件

```java
    @Test
    public void test03(){
        //删除邮箱为空的数据
        QueryWrapper<User> queryWrapper=new QueryWrapper<>();
        QueryWrapper<User> email = queryWrapper.isNull("email");
        int delete = userMapper.delete(email);
        System.out.println(delete);
    }
```

![1653299426163](/JavaCore/img/MyBatisPlus/MyBatis-Plus-30.png)

#### d>例4：条件的优先级

```java
    @Test
    public void test04(){
        //组装修改条件  将(年龄大于20并且用户名中包含有a)或邮箱为null的用户信息修改
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        QueryWrapper<User> wrapper = queryWrapper.gt("age", 20)
                .like("user_name", "B")
                .or()
                .isNull("email");
        User user = new User();
        user.setName("小明");
        user.setEmail("yangzhou@qq.com");
        int result = userMapper.update(user, wrapper);
        System.out.println(result);
    }
```

![1653299881277](/JavaCore/img/MyBatisPlus/MyBatis-Plus-31.png)


```JAVA
  @Test
    public void test05(){
        //将用户名中包含三并且（年龄大于20或邮箱为null）的用户信息修改
        //Lambda中条件优先执行
        //SQL:UPDATE t_user SET user_name=?, email=? WHERE is_deleted=0 AND (user_name LIKE ? AND (age > ? OR email IS NOT NULL))
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.like("user_name","三")
                .and(i->i.gt("age",20).or().isNotNull("email"));
        User user = new User();
        user.setName("小红");
        user.setEmail("yangzhou@qq.com");
        int update = userMapper.update(user, queryWrapper);
        System.out.println(update);
    }
```

![1653579974470](/JavaCore/img/MyBatisPlus/MyBatis-Plus-32.png)

#### e>例5：组装select子句

```java
    @Test
    public void test06(){
        //只查询username、age、email字段
        //SQL:SELECT user_name,age,email FROM t_user WHERE is_deleted=0
        QueryWrapper<User> queryWrapper=new QueryWrapper<>();
        queryWrapper.select("user_name","age","email");
        List<Map<String, Object>> maps = userMapper.selectMaps(queryWrapper);
        maps.forEach(System.out::println);
    }
```

![1653580348034](/JavaCore/img/MyBatisPlus/MyBatis-Plus-33.png)

#### f>例6：实现子查询

```java
    @Test
    public void test07(){
        //查询id小于等于100的用户信息
        //SQL:SELECT uid,user_name AS Name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (uid IN (select uid from t_user where uid<= 100))
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.inSql("uid", "select uid from t_user where uid<= 100");
        List<User> userList = userMapper.selectList(queryWrapper);
        userList.forEach(System.out::println);
    }
```

![1653795341934](/JavaCore/img/MyBatisPlus/MyBatis-Plus-35.png)

### 3、UpdateWrapper

```java
    @Test
    public void test08(){
        //将用户名中包含三并且（年龄大于20或邮箱为null）的用户信息修改
        //SQL:UPDATE t_user SET user_name=?,email=? WHERE is_deleted=0 AND (user_name LIKE ? AND (age > ?) OR email IS NULL)
        UpdateWrapper<User> userUpdateWrapper=new UpdateWrapper<>();
        userUpdateWrapper.like("user_name","a")
                .and(i->i.gt("age",20))
                .or()
                .isNull("email");
        userUpdateWrapper.set("user_name","小黑").set("email","23@qq.com");
        int update = userMapper.update(null, userUpdateWrapper);
        System.out.println(update);
    }
```

![1653795456483](/JavaCore/img/MyBatisPlus/MyBatis-Plus-36.png)

### 4、Condition

在真正开发的过程中，组装条件是常见的功能，**而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件**，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果

#### 思路一

```java
 // 模拟开发中组装条件的情况
    @Test
    public void test09(){
            //SQL:SELECT uid,user_name AS Name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (age >= ? AND age <= ?)
            String username = "";
            Integer ageBegin = 20;
            Integer ageEnd = 30;
            QueryWrapper<User> queryWrapper = new QueryWrapper<>();
            if (StringUtils.isNotBlank(username)){
                //isNotBlank判断某个字符串是否不为空，不为null,不为空白符
                queryWrapper.like("user_name",username);
            }
            if (ageBegin != null){
                queryWrapper.ge("age",ageBegin);
            }
            if (ageEnd != null){
                queryWrapper.le("age",ageEnd);
            }
        List<User> users = userMapper.selectList(queryWrapper);
            users.forEach(System.out::println);
    }
```

#### 思路二

> 上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，`简化代码的编写`

```java
    @Test
    public void test10(){
        String username = "小";
        Integer ageBegin = 20;
        Integer ageEnd = 30;
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.like(StringUtils.isNotBlank(username),"user_name",username)
                .ge(ageBegin !=null,"age",ageBegin)
                .le(ageEnd !=null,"age",ageEnd);
        List<User> users = userMapper.selectList(queryWrapper);
        users.forEach(System.out::println);

    }
```

![1653796392120](/JavaCore/img/MyBatisPlus/MyBatis-Plus-37.png)

### 5、LambdaQueryWrapper

```JAVA
    // LambdaQueryWrapper
    @Test
    public void test11(){
        // SQL:SELECT uid,user_name AS Name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (user_name LIKE ? AND age >= ? AND age <= ?)
        String username = "小";
        Integer ageBegin = 20;
        Integer ageEnd = 30;
        LambdaQueryWrapper<User> lambdaQueryWrapper=new LambdaQueryWrapper<>();
        lambdaQueryWrapper.like(StringUtils.isNotBlank(username),User::getName,username)
                .ge(ageBegin != null,User::getAge,ageBegin)
                .le(ageEnd != null,User::getAge,ageEnd);
        List<User> users = userMapper.selectList(lambdaQueryWrapper);
        users.forEach(System.out::println);
    }
```

![1653796674607](/JavaCore/img/MyBatisPlus/MyBatis-Plus-38.png)

### 6、LambdaUpdateWrapper

```java
@Test
    public void test12(){
        // SQL：UPDATE t_user SET user_name=?,email=? WHERE is_deleted=0 AND (user_name LIKE ? AND (age > ?) OR email IS NULL)
        String username = "小";
        Integer ageBegin = 20;
        Integer ageEnd = 30;
        LambdaUpdateWrapper<User> lambdaUpdateWrapper = new LambdaUpdateWrapper<>();
        lambdaUpdateWrapper.like(User::getName,"黑")
                .and(i->i.gt(User::getAge,20))
                .or()
                .isNull(User::getEmail);
        lambdaUpdateWrapper.set(User::getName,"小红").set(User::getEmail,"23@qq.com");
        int update = userMapper.update(null, lambdaUpdateWrapper);
        System.out.println(update);
    }
```

![1653797242164](/JavaCore/img/MyBatisPlus/MyBatis-Plus-39.png)

## 六、插件

### 1、分页插件

> MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能

#### a>添加配置类

```java
@Configuration
@MapperScan("com.yz.mybatisplus.mapper")
public class MybatisPlusConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }

    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return configuration -> configuration.setUseDeprecatedExecutor(false);
    }
}
```

#### b>测试

```java
 @Test
    public void testPage(){
        Page<User> page = new Page<>(1,3);

        Page<User> userPage = userMapper.selectPage(page, null);
        System.out.println( page.getRecords());
        System.out.println("总页数:"  + page.getPages());
        System.out.println("总记录数" + page.getTotal());
        System.out.println("是否有上一页" + page.hasNext());
        System.out.println("是否有下一页:" + page.hasPrevious());
    }
```

![1653799470920](/JavaCore/img/MyBatisPlus/MyBatis-Plus-40.png)

### 2、xml自定义分页

#### a>UserMapper中定义接口方法

```java
    Page<User> selectUserPage(@Param("page")Page<User> page,@Param("uid") Integer uid);
```

#### b>UserMapper.xml中编写SQL

```xml
    <select id="selectUserPage" resultType="com.yz.mybatisplus.entity.User">
        select * from t_user  where uid = #{uid}
    </select>
```

#### c> 测试

```java
@Test
    public void testPageVo(){
        Page<User> page = new Page<>(1,3);
        userMapper.selectUserPage(page,5);
        System.out.println( page.getRecords());
        System.out.println("总页数:"  + page.getPages());
        System.out.println("总记录数" + page.getTotal());
        System.out.println("是否有上一页" + page.hasNext());
        System.out.println("是否有下一页:" + page.hasPrevious());
    }
```

![1653800569870](/JavaCore/img/MyBatisPlus/MyBatis-Plus-41.png)

### 3、乐观锁

#### a>场景

> 一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小
>
> 李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太
>
> 高，可能会影响销量。又通知小王，你把商品价格降低30元。
>
> 此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王
>
> 也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50=150元存入了数据
>
> 库；小王将商品减了30元，并将100-30=70元存入了数据库。是的，如果没有锁，小李的操作就
>
> 完全被小王的覆盖了。
>
> 现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1
>
> 万多。

#### b>乐观锁和悲观锁

> 上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。
>
> 如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证
>
> 最终的价格是120元。

## Mybatis-plus最新代码生成器（3.5.1+）的使用

### 1.引入依赖：

```xml
<!--mybatisPlus-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.3.4</version>
</dependency>
<!--mybatis-plus代码生成器-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-generator</artifactId>
    <version>3.5.1</version>
</dependency>
<!--velocity模板-->
<dependency>
    <groupId>org.apache.velocity</groupId>
    <artifactId>velocity-engine-core</artifactId>
    <version>2.3</version>
</dependency>
<!--freemarker模板-->
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
</dependency>
<!--mysql-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

### 2.myentity.java.ftl
resource目录下的templates目录下创建名为myentity.java.ftl的文件，内容如下：

```java
package ${package.Entity};

<#list table.importPackages as pkg>
import ${pkg};
</#list>
<#if swagger>
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
</#if>
<#if entityLombokModel>
import lombok.Data;
    <#if chainModel>
import lombok.experimental.Accessors;
    </#if>
</#if>

/**
 * <p>
 * ${table.comment!}
 * </p>
 *
 * @author ${author}
 * @since ${date}
 */
<#if entityLombokModel>
@Data
    <#if chainModel>
@Accessors(chain = true)
    </#if>
</#if>
<#if table.convert>
@TableName("${schemaName}${table.name}")
</#if>
<#if swagger>
@ApiModel(value = "${entity}对象", description = "${table.comment!}")
</#if>
<#if superEntityClass??>
public class ${entity} extends ${superEntityClass}<#if activeRecord><${entity}></#if> {
<#elseif activeRecord>
public class ${entity} extends Model<${entity}> {
<#elseif entitySerialVersionUID>
public class ${entity} implements Serializable {
<#else>
public class ${entity} {
</#if>
<#if entitySerialVersionUID>

    private static final long serialVersionUID = 1L;
</#if>
<#-- ----------  BEGIN 字段循环遍历  ---------->
<#list table.fields as field>
    <#if field.keyFlag>
        <#assign keyPropertyName="${field.propertyName}"/>
    </#if>

    <#if field.comment!?length gt 0>
        <#if swagger>
    @ApiModelProperty("${field.comment}")
        <#else>
    /**
     * ${field.comment}
     */
        </#if>
    </#if>
    <#if field.keyFlag>
        <#-- 主键 -->
        <#if field.keyIdentityFlag>
    @TableId(value = "${field.annotationColumnName}", type = IdType.AUTO)
        <#elseif idType??>
    @TableId(value = "${field.annotationColumnName}", type = IdType.${idType})
        <#elseif field.convert>
    @TableId("${field.annotationColumnName}")
        </#if>
        <#-- 普通字段 -->
    <#elseif field.fill??>
    <#-- -----   存在字段填充设置   ----->
        <#if field.convert>
    @TableField(value = "${field.annotationColumnName}", fill = FieldFill.${field.fill})
        <#else>
    @TableField(fill = FieldFill.${field.fill})
        </#if>
    <#elseif field.convert>
    @TableField("${field.annotationColumnName}")
    </#if>
    <#-- 乐观锁注解 -->
    <#if field.versionField>
    @Version
    </#if>
    <#-- 逻辑删除注解 -->
    <#if field.logicDeleteField>
    @TableLogic
    </#if>
    private ${field.propertyType} ${field.propertyName};
</#list>
<#------------  END 字段循环遍历  ---------->

<#if !entityLombokModel>
    <#list table.fields as field>
        <#if field.propertyType == "boolean">
            <#assign getprefix="is"/>
        <#else>
            <#assign getprefix="get"/>
        </#if>
    public ${field.propertyType} ${getprefix}${field.capitalName}() {
        return ${field.propertyName};
    }

    <#if chainModel>
    public ${entity} set${field.capitalName}(${field.propertyType} ${field.propertyName}) {
    <#else>
    public void set${field.capitalName}(${field.propertyType} ${field.propertyName}) {
    </#if>
        this.${field.propertyName} = ${field.propertyName};
        <#if chainModel>
        return this;
        </#if>
    }
    </#list>
</#if>

<#if entityColumnConstant>
    <#list table.fields as field>
    public static final String ${field.name?upper_case} = "${field.name}";

    </#list>
</#if>
<#if activeRecord>
    @Override
    public Serializable pkVal() {
    <#if keyPropertyName??>
        return this.${keyPropertyName};
    <#else>
        return null;
    </#if>
    }

</#if>
<#if !entityLombokModel>
    @Override
    public String toString() {
        return "${entity}{" +
    <#list table.fields as field>
        <#if field_index==0>
            "${field.propertyName}=" + ${field.propertyName} +
        <#else>
            ", ${field.propertyName}=" + ${field.propertyName} +
        </#if>
    </#list>
        "}";
    }
</#if>
}
```

### 3.Generator

```java
package com.yz.springbootadmin;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.generator.FastAutoGenerator;
import com.baomidou.mybatisplus.generator.config.OutputFile;
import com.baomidou.mybatisplus.generator.config.TemplateConfig;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

/**
 * @Author 杨洲
 * @Date 2022/6/15 19:29
 */
public class Generator {
    public static void main(String[] args) {
        List<String> tables = new ArrayList<>();
        tables.add("sys_user");


        FastAutoGenerator.create("jdbc:mysql://localhost:3306/test","root","123456")
                .globalConfig(builder -> {
                    builder.author("向培")               //作者
                            .outputDir(System.getProperty("user.dir")+"\\src\\main\\java")    //输出路径(写到java目录)
                            .enableSwagger()           //开启swagger
                            .commentDate("yyyy-MM-dd")
                            .fileOverride();            //开启覆盖之前生成的文件

                })
                .packageConfig(builder -> {
                    builder.parent("com.yz")
                            .moduleName("springbootadmin")
                            .entity("entity")
                            .service("service")
                            .serviceImpl("service.impl")
                            .controller("controller")
                            .mapper("mapper")
                            .xml("mapper")
                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml,System.getProperty("user.dir")+"\\src\\main\\resources\\mapper"));
                })
                .strategyConfig(builder -> {
                    builder.addInclude(tables)
                            .addTablePrefix("p_")
                            .serviceBuilder()
                            .formatServiceFileName("%sService")
                            .formatServiceImplFileName("%sServiceImpl")
                            .entityBuilder()
                            .enableLombok()
                            .logicDeleteColumnName("deleted")
                            .enableTableFieldAnnotation()
                            .controllerBuilder()
                            // 映射路径使用连字符格式，而不是驼峰
                            .enableHyphenStyle()
                            .formatFileName("%sController")
                            .enableRestStyle()
                            .mapperBuilder()
                            //生成通用的resultMap
                            .enableBaseResultMap()
                            .superClass(BaseMapper.class)
                            .formatMapperFileName("%sMapper")
                            .enableMapperAnnotation()
                            .formatXmlFileName("%sMapper");
                })
                .templateConfig(new Consumer<TemplateConfig.Builder>() {
                    @Override
                    public void accept(TemplateConfig.Builder builder) {
                        // 实体类使用我们自定义模板
                        builder.entity("templates/myentity.java");
                    }
                })
                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                .execute();
    }
}
```

### 4.使用swagger-ui

#### 4.1 引入依赖

```xml
<dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>swagger-bootstrap-ui</artifactId>
            <version>1.9.6</version>
        </dependency>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>20.0</version>
</dependency>
```

#### 4.2 配置类

在com.yz.springbootadmin.config包下创建SwaggerConfig

```java
package com.yz.springbootadmin.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * @Author 杨洲
 * @Date 2022/6/15 19:41
 */
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    Docket docket() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.yz.springbootadmin.controller"))
                .paths(PathSelectors.any())
                .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("测试文档")
                .description("DEMO项目的接口测试文档")
                .termsOfServiceUrl("https://mryz0.github.io/JavaStudy/")
                .version("1.0")
                .contact(new Contact("杨洲",
                        "https://mryz0.github.io/JavaStudy/",
                        "hangge@hangge.com"))
                .build();
    }

}
```

