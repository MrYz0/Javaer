---
title: 线程的生命周期及状态转换
date: 2022-07-21 20:04:20
permalink: /pages/6904ab/
categories:
  - 《Java教程》笔记
  - 多线程
tags:
  - 
author: 
  name: 杨洲
  link: https://github.com/xugaoyi
---

# 线程的生命周期及状态转换

## 概念

在Java中，任何对象都有生命周期，**线程也不例外，它也有自己的生命周期**。当Thread对象创建完成时，线程的生命周期便开始了。当线程任务中代码正常执行完毕或者线程抛出一个未捕获的异常（Exception）或者错误（Error）时，线程的生命周期便会结束。Java官方API将线程的整个生命周期分为6个状态，分别是NEW（新建状态）、RUNNNABLE（可运行状态）、BLOCKED（阻塞状态）、WAITING（等待状态）、TIMEDWAITING（定时等待状态）和TERMINATED（终止状态）.

下图展示了线程各种状态的转换关系，剪头方向表示可转换的方向。接下来，针对线程生命周期中的6种状态分别进行详细讲解，具体如下。

![image-20220621103845655](/JavaCore/img/Java/多线程/多线程-10.png)

## NEW（新建状态）

创建一个线程对象后，该线程对象就处于新建状态，此时它不能运行，和其他Java对象一样，仅仅由JVM为其分配了内存，没有表现出任何线程的动态特征。

## RUNNNABLE（可运行状态）

**当新建状态下的线程对象调用了start()方法，此时就会从新建状态进入可运行状态。从上图可以看出，在RUNNABLE状态内部又可细分为两种状态：READY（就绪状态）和RUNNING（运行状态），并且线程可以在这两个状态之间相互转换**。

①就绪状态：线程对象调用了start()方法之后，等待JVM的调度，此时线程并没有运行；

②运行状态：线程对象获得了JVM调度，如果存在多个CPU，那么允许多个线程并行运行。

## BLOCKED（阻塞状态）

**处于运行状态的线程可能会因为某些原因失去CPU的执行权，暂时停止运行进入阻塞状态。阻塞状态的进程只能先进入就绪状态，不能直接进入运行状态**。

线程一般会在一下两种情况下进入阻塞状态：

①当线程A运行过程中，试图获得同步锁时，却被线程B获取，此时JVM把当前线程A存到对象的锁池中，线程A就会进入阻塞状态；

②当线程运行过程中，发出I.O请求时，此时线程也会进入阻塞状态。

## WAITING（等待状态）

**当处于运行状态的线程调用了与时间参数限制的方法后，如wait()、join()等方法，就会将当前运行中的线程转换为等待状态**。

处于等待状态中的线程不能立即争夺CPU使用权，必须等待其他线程执行特定的操作后，才有机会再次争夺CPU使用权，将等待状态的线程转换为运行状态。例如，调用wait()方法而处于等待状态中的线程，必须等待其他线程调用了notify()或者notifyAll()方法唤醒当前等待中的线程；调用了join()方法而处于等待状态中的线程，就必须等待其他加入的线程终止。

## TIMEDWAITING（定时等待状态）

将运行状态中的线程转换为定时等待状态中的线程与转换为等待状态中的线程操作类似，只是运行线程调用了有时间参数限制的方法，如sleep(long millis)、wait(long timeout)、join(long millis)等方法。

处于定时等待状态的线程也不能立即争夺CPU使用权，必须等待其他相关线程执行完特定的操作或限制时间结束后，才有机会再次争夺CPU使用权，将定时等待状态线程转换为运行状态。例如，调用了wait(long timeout)方法而处于等待状态中的线程，需要通过其他线程调用notify()或者notifyAll()方法唤醒当前等待中的线程，或者等待限时时间结束后也可以进行状态转换。

## TERMINATED（终止状态）

线程的run()方法、call()方法正常执行完毕或者线程抛出一个未捕获的异常（Excepiton）、错误（Error），线程就会进入终止状态。一旦进入终止状态，线程将不再拥有运行的资格，也不能再转换到其他状态，生命周期结束。

